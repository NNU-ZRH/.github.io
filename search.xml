<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker入门与项目部署</title>
      <link href="/2023/02/09/Docker/"/>
      <url>/2023/02/09/Docker/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/image-20240324201829664.png" alt="image-20240324201829664"></p><h1 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h1><h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><p><code>brew installl docker安装Docker Desktop</code></p><p><code>打开docker图形界面-&gt;settings-&gt;Docker Engine-&gt;添加阿里云镜像</code></p><h1 id="示例：部署MySQL"><a href="#示例：部署MySQL" class="headerlink" title="示例：部署MySQL"></a>示例：部署MySQL</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3307</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p><code>-d</code>：让容器在后台运行</p><p><code>--name</code>：给容器起个名字</p><p><code>-p 3306:3306</code>：端口映射 宿主机端口：容器端口【连接要连接宿主机端口】</p><p><code>-e</code>：环境变量：KEY&#x3D;VALUEE 来设置环境变量</p><p><code>mysql:5.7</code>：指定运行的镜像的名字：版本</p><p><span style="color:red">docker run是一条龙服务，会先检查本地镜像是否存在，然后拉取，然后创建容器</span></p><h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/image-20240322233738345.png" alt="image-20240322233738345"></p><p><code>docker pull</code>：从镜像仓库拉取镜像到本地</p><p><code>docker build</code>：创建自定义镜像</p><p><code>docker push</code>：把镜像推到镜像仓库</p><p><code>docker images</code>：查看本地镜像</p><p><code>docker rmi</code>：删除本地镜像</p><p><code>docker run</code>：创建并运行容器</p><p><code>docker stop</code>：停止容器（并不会删除容器，只是停止镜像线程）</p><p><code>docker start</code>：启动容器</p><p><code>docker ps</code>：查看当前容器的运行状态</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可以加格式化方式访问，格式会更加清爽</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以设置命令别名简化</span></span><br><span class="line">dps</span><br></pre></td></tr></table></figure><p><code>docker ps -a</code>：查看当前所有所有容器，包括stop的容器</p><p><code>docker rm</code>：删除容器</p><p><code>docker logs</code>：查看容器运行的日志</p><p><code>docker exec</code>进入容器内部</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入mysql容器的bash窗口</span></span><br><span class="line">docker exec <span class="literal">-t</span> mysql bash </span><br></pre></td></tr></table></figure><h1 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h1><h2 id="数据卷挂载"><a href="#数据卷挂载" class="headerlink" title="数据卷挂载"></a>数据卷挂载</h2><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机</strong>目录之间映射的桥梁</p><p>以Nginx为例，我们知道Nginx中有两个关键的目录：</p><ul><li><code>html</code>：放置一些静态资源</li><li><code>conf</code>：放置配置文件</li></ul><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/image-20240324144926392.png" alt="image-20240324144926392"></p><p>注意：容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></span><br><span class="line"><span class="comment"># 数据卷的名字：容器中数据卷的目录</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> <span class="literal">-v</span> html:/usr/share/nginx/html nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     <span class="number">29524</span>ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</span><br><span class="line">local     html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看数据卷详情</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2024-05-17T19:57:08+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/html/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看/var/lib/docker/volumes/html/_data目录</span></span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 可以看到与nginx的html目录内容一样，结果如下：</span></span><br><span class="line">总用量 <span class="number">8</span></span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">497</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> <span class="number">50</span>x.html</span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">615</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.进入该目录，并随意修改index.html内容</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br></pre></td></tr></table></figure><h2 id="本地目录挂载"><a href="#本地目录挂载" class="headerlink" title="本地目录挂载"></a>本地目录挂载</h2><p>可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="comment"># 挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-v mysql:/var/lib/mysql <span class="comment"># 会被识别为一个数据卷叫mysql，运行时会自动创建这个数据卷</span></span><br><span class="line">-v ./mysql:/var/lib/mysql <span class="comment"># 会被识别为当前目录下的mysql目录，运行时如果不存在会创建目录</span></span><br></pre></td></tr></table></figure><p>以初始化挂载MySQl为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.删除原来的MySQL容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.创建并运行新mysql容器，挂载本地目录</span></span><br><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3307:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=zrh015658 \</span><br><span class="line">  -v /Users/zrh/DockerFile/mysql/data:/var/lib/mysql \</span><br><span class="line">  -v /Users/zrh/DockerFile/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v /Users/zrh/DockerFile/mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看root目录，可以发现~/mysql/data目录已经自动创建好了</span></span><br><span class="line"><span class="built_in">ls</span> -l mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">总用量 4</span><br><span class="line">drwxr-xr-x. 2 root    root   20 5月  19 15:11 conf</span><br><span class="line">drwxr-xr-x. 7 polkitd root 4096 5月  19 15:11 data</span><br><span class="line">drwxr-xr-x. 2 root    root   23 5月  19 15:11 init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看data目录，会发现里面有大量数据库数据，说明数据库完成了初始化</span></span><br><span class="line"><span class="built_in">ls</span> -l data</span><br></pre></td></tr></table></figure><h1 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h1><p>镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><ol><li>镜像打包</li></ol><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。</p><p>而这种记录镜像结构的文件就称为<strong>Dockerfile</strong>，其对应的语法可以参考官方文档：</p><p>例如，要基于Ubuntu镜像来构建一个Java应用，其Dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录、容器内时区</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="comment"># 指定项目监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>我们会有很多很多java项目需要打包为镜像，他们都需要Linux系统环境、JDK环境这两层，只有上面的3层不同（因为jar包不同）。如果每次制作java镜像都重复制作前两层镜像，是不是很麻烦。所以，就有人提供了基础的系统加JDK环境，我们在此基础上制作java镜像，就可以省去JDK的配置了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><ol start="2"><li>构建镜像</li></ol><p>在&#x2F;root&#x2F;demo里准备个jar包及对应的Dockerfile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接指定Dockerfile目录</span></span><br><span class="line">docker build -t docker-demo:1.0 /root/demo</span><br><span class="line"><span class="comment"># 当前文件夹</span></span><br><span class="line">docker build -t docker-demo:1.0 .</span><br></pre></td></tr></table></figure><ol start="3"><li>创建容器运行镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.创建并运行容器</span></span><br><span class="line">docker run -d --name <span class="built_in">dd</span> -p 8080:8080 docker-demo:1.0</span><br></pre></td></tr></table></figure><h2 id="网络互联"><a href="#网络互联" class="headerlink" title="网络互联"></a>网络互联</h2><p>而Java项目往往需要访问其它各种中间件，例如MySQL、Redis等。现在，我们的容器之间能否互相访问呢</p><p>可以互联，但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败。所以，<strong>我们必须借助于docker的网络功能来解决这个问题：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.首先通过命令创建一个网络</span></span><br><span class="line">docker network create hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">639bc44d0a87   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">403f16ec62a2   hmall     bridge    <span class="built_in">local</span></span><br><span class="line">0dc0f72a0fbb   host      host      <span class="built_in">local</span></span><br><span class="line">cd8d3e8df47b   none      null      <span class="built_in">local</span></span><br><span class="line"><span class="comment"># 其中，除了hmall以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span></span><br><span class="line"><span class="comment"># 这样该网络内的其它容器可以用别名互相访问！</span></span><br><span class="line"><span class="comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span></span><br><span class="line">docker network connect hmall mysql --<span class="built_in">alias</span> db</span><br><span class="line"><span class="comment"># 3.2.db容器，也就是我们的java项目</span></span><br><span class="line">docker network connect hmall <span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.进入dd容器，尝试利用别名访问db</span></span><br><span class="line"><span class="comment"># 4.1.进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"><span class="comment"># 4.2.用db别名访问</span></span><br><span class="line">ping db</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING db (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms</span><br><span class="line"><span class="comment"># 4.3.用容器名访问</span></span><br><span class="line">ping mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">PING mysql (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure><h1 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h1><h2 id="分别部署"><a href="#分别部署" class="headerlink" title="分别部署"></a>分别部署</h2><p>一般来说，项目会多环境开发：</p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/image-20240324180928266.png" alt="image-20240324180928266" style="zoom:50%;" /><p>其中的<code>application-dev.yaml</code>是部署到开发环境的配置，<code>application-local.yaml</code>是本地运行时的配置</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/image-20240324182046200.png" alt="image-20240324182046200"></p><p>查看application.yaml，你会发现其中的JDBC地址并未写死，而是读取变量</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/image-20240324182020122.png" alt="image-20240324182020122"></p><p>在dev开发环境（也就是Docker部署时）采用了mysql作为地址，刚好是我们的mysql容器名，只要两者在一个网络，就一定能互相访问</p><p>部署完后端，部署前端，Nginx，MySQL等….</p><h2 id="关联部署"><a href="#关联部署" class="headerlink" title="关联部署"></a>关联部署</h2><p><strong>DockerCompose</strong></p><p>示例：</p><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="comment"># MySQL镜像</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">  <span class="comment"># 自定义镜像</span></span><br><span class="line">  <span class="attr">hmall:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">    <span class="attr">depends_on:</span> <span class="comment">#依赖于mysql容器的服务</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="comment"># Nginx镜像</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">hm-net:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前yml文件的位置启动</span></span><br><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/10/hello-world/"/>
      <url>/2022/09/10/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/image-20240203223335890.png" alt="image-20240203223335890"></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE</title>
      <link href="/2022/02/10/JAVA/"/>
      <url>/2022/02/10/JAVA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-JAVA简述"><a href="#1-JAVA简述" class="headerlink" title="1. JAVA简述"></a>1. JAVA简述</h1><p><a href="https://baike.baidu.com/item/Java%E5%B9%B3%E5%8F%B0/3793459?fromModule=lemma_inlink">Java平台</a>由<a href="https://baike.baidu.com/item/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/6810577?fromModule=lemma_inlink">Java虚拟机</a>(Java Virtual Machine)和Java 应用<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3/3339711?fromModule=lemma_inlink">编程接口</a>(Application Programming Interface、简称<a href="https://baike.baidu.com/item/API/10154?fromModule=lemma_inlink">API</a>)构成。Java 应用编程接口为Java应用提供了一个独立于操作系统的<a href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E6%8E%A5%E5%8F%A3/7681027?fromModule=lemma_inlink">标准接口</a>，可分为基本部分和扩展部分。在硬件或操作系统平台上安装一个Java平台之后，Java应用程序就可运行。Java平台已经嵌入了几乎所有的操作系统。这样Java程序可以只编译一次，就可以在各种系统中运行。Java应用编程接口已经从1.1x版发展到1.2版。常用的Java平台基于Java1.8。</p><ul><li><p>JRE：只需要运行JAVA程序</p></li><li><p>JDK：用于开发，我用的版本：JDK8</p></li><li><p>SE主要用于桌面开发，其中一部分核心的是EE也要学的共同</p><p>的基础部分，所以我们叫SE为基础版，是企业级开发的基础</p></li><li><p>JAVA语言的特性：跨平台性</p></li></ul><p><strong>JDK8安装</strong></p><ol><li><p>oracle下载jdk8u311</p></li><li><p>下一步下一步安装即可（路径不要有中文）</p></li><li><p>安装完成后只有进入到这个文件夹才能执行javac.exe等，所以要配置环境变量（在任何目录都可以执行）</p></li><li><p><span style="background:yellow">配置环境变量</span></p><ul><li><p>新建一个JAVA_HOME变量，值是bin所在文件夹</p></li><li><p>在path里建一个bin里文件的路径</p><p>可以下载多个版本jdk，环境变量配置谁就用哪个版本的jdk</p></li></ul></li></ol><h1 id="2-Windows常用cmd命令"><a href="#2-Windows常用cmd命令" class="headerlink" title="2. Windows常用cmd命令"></a>2. Windows常用cmd命令</h1><ol><li><p>cmd打开命令行窗口</p></li><li><p>d:，回车进入d盘（可以不加cd ）</p><ul><li><p>dir  显示当前</p></li><li><p>md 创建文件目录</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> str&gt;<span class="number">1</span>.txt</span><br><span class="line">创建文件<span class="number">1</span>.txt 并将str写入该文件</span><br></pre></td></tr></table></figure></li><li><p>cd filename 进入目录</p></li></ul></li><li><p>cd.. 返回上一级目录  </p><p>cd filename 返回指定目录</p><p>cd\ 返回到根目录</p></li><li><blockquote><p>del 1.txt   删除1.txt这个文件</p><p>del *.txt  删除所有txt后缀的文件</p><p>del 文件目录名字（删除该目录下所有文件，目录不删）</p><p>rd 文件目录名  （删除目录，目录需为空才能删除）</p></blockquote></li><li><p>执行完上一条命令后，按↑即可快速再次执行该命令</p></li></ol><h1 id="3-HelloWorld"><a href="#3-HelloWorld" class="headerlink" title="3. HelloWorld"></a>3. HelloWorld</h1><ol><li><ul><li>新建一个.java文件（用记事本打开）</li><li>java代码编写.java文件；javac命令编译java文件成为字节码.class文件；java命令运行字节码文件</li></ul></li><li><p>文档注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">bbbbb</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">解释说明此function</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">funion</span><br><span class="line">注释内容可以被JDK提供的工具javadoc解析，生成一套网页文件的说明文档</span><br></pre></td></tr></table></figure><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javadoc -d 文件名 -author -version filename.java</span><br><span class="line">//完成后可以在文件名的文件夹中找到index.html文档</span><br></pre></td></tr></table></figure></li></ol><h1 id="4-JAVA基本语法"><a href="#4-JAVA基本语法" class="headerlink" title="4. JAVA基本语法"></a>4. JAVA基本语法</h1><h2 id="4-1-关键字和保留字"><a href="#4-1-关键字和保留字" class="headerlink" title="4.1 关键字和保留字"></a>4.1 关键字和保留字</h2><p>保留字：go to   const,以后可能会用，但现在不用。不要用作标识符</p><h2 id="4-2-标识符"><a href="#4-2-标识符" class="headerlink" title="4.2 标识符"></a>4.2 标识符</h2><p>命名规则：</p><ol><li>由26个英文字母大小写，0-9，_或$组成</li><li>数字不可以开头</li><li>不能使用关键字和保留字，但能包含关键字和保留字</li><li>不能包含空格</li><li>Java中严格区分大小写，长度无限制</li></ol><p>命名规范：</p><ol><li>包名：多单词组成时所有字母都小写xxxyyyzzz</li><li>类名，接口名：多单词组成时，所有单词首字母大写XxxYyyZzz</li><li>变量名，方法名：第一个单词字母小写，第二个开始首字母大写xxxYyyZzz</li><li>常量名：所有字母都大写，多单词用下划线连接XXX_YYY_ZZZ</li></ol><h2 id="4-3-数据类型和运算符"><a href="#4-3-数据类型和运算符" class="headerlink" title="4.3 数据类型和运算符"></a>4.3 数据类型和运算符</h2><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071309385.png" alt="image-20230707130929294"></p><h3 id="4-3-1-整型"><a href="#4-3-1-整型" class="headerlink" title="4.3.1 整型"></a>4.3.1 整型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="number">128</span>;<span class="comment">//超出范围，编译不通过</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">17371731379L</span><span class="comment">//long型要以l或者L结尾（打印不会打印出来）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="number">121</span>;<span class="comment">//把一个int型121赋值给long型变量l2(有一个自动类型转换的过程)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>java默认整型常量为int，声明long型常量须后加‘l’或者‘L’</p></li><li><p>byte：1字节</p><p>short：2字节</p><p>int：4字节</p><p>long：8字节</p><p>Byte或者B是字节，bit是二进制位</p></li></ul><h3 id="4-3-2-浮点型"><a href="#4-3-2-浮点型" class="headerlink" title="4.3.2 浮点型"></a>4.3.2 浮点型</h3><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071315849.png" alt="image-20230707131530748"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">12.3f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">12.1212</span>;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-字符类型"><a href="#4-3-3-字符类型" class="headerlink" title="4.3.3 字符类型"></a>4.3.3 字符类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//char 字符 = 两个字节2byte = 16bit</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> c1 + <span class="number">1</span>;<span class="comment">//i1=98  + 有字符串就是连接，没有就是运算</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;\n&#x27;</span><span class="comment">//转义字符</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;\u0043&#x27;</span><span class="comment">//Unicode编码集0043对应的字符</span></span><br><span class="line"></span><br><span class="line">计算机底层是<span class="number">2</span>进制文件存储。</span><br><span class="line">    会采用不同的编码方式Unicode（具体有UTF-<span class="number">8</span>等），gbk等</span><br><span class="line">    使用不同的解码方式就会乱码。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\n&quot;</span>  转义换行</span><br><span class="line">    <span class="string">&quot;\\n&quot;</span>  直接就是字符\n</span><br><span class="line">    <span class="string">&quot;\&quot;zrh\&quot;&quot;</span>   转义让编译器不要把我们的双引号误以为是字符串的结束的标志</span><br></pre></td></tr></table></figure><h3 id="4-3-4-基本数据类型运算的规则"><a href="#4-3-4-基本数据类型运算的规则" class="headerlink" title="4.3.4 基本数据类型运算的规则"></a>4.3.4 基本数据类型运算的规则</h3><ul><li>自动类型提升</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> b1 + i1;<span class="comment">//自动提升为容量大的类型 </span></span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> b1 + b2;<span class="comment">//自动类型转换（提升类型）</span></span><br></pre></td></tr></table></figure><p>byte char short–&gt;int–&gt;long–&gt;float–&gt;double</p><p><span style="background:yellow">前三者运算应用int型接收，即使是byte+byte</span></p><p><span style="background:yellow">整型常量默认为int，浮点类型默认为float</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">s1 = s1 + <span class="number">2</span>;<span class="comment">//编译失败，short+int应该为int</span></span><br><span class="line">S1 += <span class="number">2</span>;<span class="comment">//编译成功，这种写法不会改变数据本身的类型</span></span><br></pre></td></tr></table></figure><p><span style="background:yellow">类似 +&#x3D;   *&#x3D;  这种是不会改变变量类型的（推荐使用）</span></p><ul><li>强制类型转换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">12.9</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> (<span class="type">int</span>)d1;<span class="comment">//i1=12,直接阶段，损失精度</span></span><br></pre></td></tr></table></figure><ul><li><pre><code class="java">//除法运算int num1 = 12;int num2 = 5;int result = num1/num2//result = 2 double result1 = num1/num2//result1 = 2.0double result2 = num1 / (num2 + 0.0)//result2 = 2.4double result3 = (double)num1 / num2;//result3 = 2.4<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 逻辑运算符</span><br><span class="line"></span><br><span class="line">![image-20230707134724813](https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071347919.png)</span><br><span class="line"></span><br><span class="line">短路与的判断方式是: </span><br><span class="line"></span><br><span class="line">从左到右依次判断，直到出现false为止将不再判断，直接得到结果为false（短路遇false就停）</span><br><span class="line"></span><br><span class="line">逻辑或和短路或的区别 逻辑或的判断方式是：</span><br><span class="line"></span><br><span class="line">从左到右依次判断，直到结尾</span><br><span class="line"></span><br><span class="line">### 4.3.5 String</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">class StringTest&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        String s1 = &quot;Hello World&quot;;</span><br><span class="line">        String s2 = &quot;&quot;;//空串</span><br><span class="line">        </span><br><span class="line">        int number = 1001;</span><br><span class="line">        String s3 = s1 + number;//字符串和其他类型的+均为连接，结果任然是字符串</span><br><span class="line">        System.out.printl(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">两种创建String的方法</span><br><span class="line">//一是new型：String s = new String(&quot;abc&quot;)；</span><br><span class="line">//另一种是双引号型：String s = &quot;abc&quot;;(相同内容的会共享内存空间)</span><br></pre></td></tr></table></figure></code></pre></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String的常见操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字符串长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line"><span class="comment">//获取字符串中的第i个字符方法</span></span><br><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(i); </span><br><span class="line"><span class="comment">//获取指定位置的字符</span></span><br><span class="line">cha[] array = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">80</span>];  <span class="comment">//先要创建以一个容量足够大的char型数组，数组名为array,1、indexBegin：需要复制的字符串的开始索引2、 indexEnd:需要复制的字符串的结束索引3、array:前面定义的char型数组的数组名4、arrayBegin:数组array开始存储的位置索引号</span></span><br><span class="line">str.getChars(indexBegin,indexEnd,array,arrayBegin);</span><br><span class="line"></span><br><span class="line"><span class="comment">//不忽略字符串大小写情况下字符串的大小比较</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> str1.compareTo(str2);</span><br><span class="line"><span class="comment">//不忽略字符串大小写情况下判别字符串相等</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> str1.equals(str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找字符（或者字符串）首次出现的位置</span></span><br><span class="line">str.indexOf(ch);</span><br><span class="line">str.indexOf(ch,fromIndex);</span><br><span class="line"><span class="comment">//最后一次出现</span></span><br><span class="line">str.lastIndexOf(ch);</span><br><span class="line">str.lastIndexOf(ch,fromIndex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//截取</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> str.substring(beginIndex,EndIndex)；</span><br><span class="line"><span class="comment">//以参数为界拆分</span></span><br><span class="line">String strArray[] = str.split(正则表达式);<span class="comment">// 拆分的结果保存到字符串数组中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="comment">/***实现字符串的替换，原字符串内容不变***/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> “abcat”;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> s.replace（‘a’，‘<span class="number">1</span>’）;<span class="comment">//替换所有字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> s.replaceAll（“ba”，“<span class="number">12</span>”）；<span class="comment">//替换所有字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> s. replaceFirst（“ba”，“<span class="number">12</span>”）；<span class="comment">//替换第一个出现的指定字符串时</span></span><br></pre></td></tr></table></figure><h3 id="4-3-6-进制"><a href="#4-3-6-进制" class="headerlink" title="4.3.6 进制"></a>4.3.6 进制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0b110</span>;<span class="comment">//二进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">110</span>;<span class="comment">//十进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">0110</span><span class="comment">//八进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="number">0x110</span><span class="comment">//十六进制</span></span><br></pre></td></tr></table></figure><ul><li><p>正数三码合一</p></li><li><p>负数<img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071410715.png" alt="image-20230707141050609"></p></li></ul><p>​<strong>补码再求一个补码就得到源码</strong></p><p><span style="background:yellow">计算机底层都以补码的形式存储数据，运算的时候，都是以补码进行运算的。</span></p><h3 id="4-3-7-位运算符"><a href="#4-3-7-位运算符" class="headerlink" title="4.3.7 位运算符"></a>4.3.7 位运算符</h3><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071411493.png" alt="image-20230707141121388"></p><ul><li><p>位运算符操作的都是整型的数据</p></li><li><p>在一定范围内：&lt;&lt; 每向左移一位，相当于*2，&gt;&gt;每向右移一位，相当于&#x2F;2</p></li><li><p>左移a</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071412560.png" alt="image-20230707141205451"></p></li><li><p>右移</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071412504.png" alt="image-20230707141254393"></p></li><li><p>无符号右移</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071413785.png" alt="image-20230707141334676"></p></li></ul><h3 id="4-3-8-三元运算符"><a href="#4-3-8-三元运算符" class="headerlink" title="4.3.8 三元运算符"></a>4.3.8 三元运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(m &gt; n)?m : n <span class="comment">//真执行m，假执行n</span></span><br></pre></td></tr></table></figure><h2 id="4-4-程序流程控制"><a href="#4-4-程序流程控制" class="headerlink" title="4.4 程序流程控制"></a>4.4 程序流程控制</h2><h3 id="4-4-1-if-else"><a href="#4-4-1-if-else" class="headerlink" title="4.4.1 if-else"></a>4.4.1 if-else</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//true执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//else就近原则配对</span></span><br><span class="line"><span class="comment">//二者选一执行</span></span><br><span class="line"><span class="keyword">if</span>()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多者选一执行</span></span><br><span class="line"><span class="keyword">if</span>()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-2-switch-case"><a href="#4-4-2-switch-case" class="headerlink" title="4.4.2 switch-case"></a>4.4.2 switch-case</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表达式只能是6种类型之一：byte short char int String 枚举</span></span><br><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句；</span><br><span class="line">        <span class="keyword">break</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果多个case条件是相同的，那么可以合并</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;Good&quot;</span>)</span><br></pre></td></tr></table></figure><p><span style="background:yellow">break在switch中是可选的，第一次根据case进来，一直往下执行，直到遇到break或者末尾才跳出switch语句结构</span></p><h3 id="4-4-3-循环"><a href="#4-4-3-循环" class="headerlink" title="4.4.3 循环"></a>4.4.3 循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//break;跳出循环结构</span></span><br><span class="line"><span class="comment">//continue;结束当前循环，进入下一次循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(初始条件，执行语句;判断语句;迭代条件，执行语句)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    setence;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//至少有一次循环</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>带标签的循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">label:<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//break默认跳出最近的循环，也可跳出默认指定标签的循环</span></span><br><span class="line">            <span class="keyword">break</span> label;<span class="comment">//直接跳出外层循环</span></span><br><span class="line">            <span class="keyword">continue</span> label;<span class="comment">//结束当前。继续外层大循环 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foreach循环(增强for循环)内部是迭代器实现<span style="background:yellow">只能用于遍历集合或者数组</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">//循环过程中不能对item做修改，否则会出错</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> item : arr)&#123;</span><br><span class="line">    system.out.print(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h1><h2 id="5-1-数组的初始化"><a href="#5-1-数组的初始化" class="headerlink" title="5.1 数组的初始化"></a>5.1 数组的初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">int</span>[] ids;</span><br><span class="line">ids = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] ids = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态初始化</span></span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//初始化值： 1、整型初始化值为0</span></span><br><span class="line">   <span class="number">2</span>、浮点型初始化值为<span class="number">0.0</span></span><br><span class="line">           <span class="number">3</span>、<span class="type">char</span>型 <span class="number">0</span>（ASCII码为<span class="number">0</span>）：格式化输出是一个空格</span><br><span class="line">           <span class="number">4</span>、（引用类型）Sting类型为 <span class="literal">null</span></span><br><span class="line"><span class="comment">//方括号可以写到数组名后</span></span><br><span class="line"></span><br><span class="line">其他写法均是错误的</span><br></pre></td></tr></table></figure><h2 id="5-2-元素索引"><a href="#5-2-元素索引" class="headerlink" title="5.2 元素索引"></a>5.2 元素索引</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//索引角标从0开始，到-1结束</span></span><br></pre></td></tr></table></figure><h2 id="5-3-获取数组长度"><a href="#5-3-获取数组长度" class="headerlink" title="5.3 获取数组长度"></a>5.3 获取数组长度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组有一个length的属性</span></span><br><span class="line">names.length</span><br></pre></td></tr></table></figure><h2 id="5-4-数组内存解析"><a href="#5-4-数组内存解析" class="headerlink" title="5.4 数组内存解析"></a>5.4 数组内存解析</h2><p>new的东西都在堆区，数组名是在栈区，指向了堆区的地址。当堆区的东西没有索引指向它的时候，内存就会被释放掉。</p><h2 id="5-5-多维数组"><a href="#5-5-多维数组" class="headerlink" title="5.5 多维数组"></a>5.5 多维数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];<span class="comment">//动态初始化二维数组，且每行长度是不固定</span></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j=<span class="number">1</span>;i&lt;arr.length;++i)&#123;</span><br><span class="line">arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建的是一个如下的二维数组</span></span><br><span class="line"><span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">arr.length<span class="comment">//有多少行</span></span><br><span class="line">arr[<span class="number">0</span>].length<span class="comment">//该行有多少列</span></span><br></pre></td></tr></table></figure><h2 id="5-6-Arrays工具类"><a href="#5-6-Arrays工具类" class="headerlink" title="5.6 Arrays工具类"></a>5.6 Arrays工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Arrays.fill()<span class="comment">//填值</span></span><br><span class="line">Arrays.toString(<span class="type">int</span>[] arr);<span class="comment">//数组转字符串 [1,2,3]带方括号的</span></span><br><span class="line"></span><br><span class="line">Arrays.asList(Integer[] arr) <span class="comment">//数组转List集合（注意这里要是包装类型的，才会把arr里的所有元素转换为list,如果是int[] arr 则会把整个数组arr当成一个元素放入list）</span></span><br><span class="line">    </span><br><span class="line">Arrays.sort(<span class="type">int</span>[] arr);<span class="comment">// 数组排序（默认降序）（要升序，只有把int[] arr转换为Integer[] arr，再传入comparator）</span></span><br><span class="line"></span><br><span class="line">Arrays.copyOf(<span class="type">boolean</span>[] original, <span class="type">int</span> newLength);<span class="comment">// 复制数组(以布尔型数组举例),没有填满新数组，默认填充</span></span><br><span class="line">Arrays.copyOfRange(<span class="type">boolean</span>[] original, <span class="type">int</span> from, <span class="type">int</span> to);<span class="comment">//指定数组索引开始和结束的范围复制数组(以布尔型数组举例)</span></span><br><span class="line">Arrays.equals(arr1,arr2); <span class="comment">//两个数组值进行比较是否相等</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//Arrays.toString返回的String带有[]</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> s:arr)&#123;</span><br><span class="line">    strb.append(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(strb);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><h1 id="6-面向对象"><a href="#6-面向对象" class="headerlink" title="6. 面向对象"></a>6. 面向对象</h1><h2 id="6-1-内存分配"><a href="#6-1-内存分配" class="headerlink" title="6.1 内存分配"></a>6.1 内存分配</h2><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071536254.png" alt="image-20230707153627122"></p><h2 id="6-2-类成员"><a href="#6-2-类成员" class="headerlink" title="6.2 类成员"></a>6.2 类成员</h2><p>成员变量：类{}里面的，可以先不赋初值。</p><p>局部变量：函数方法里面的，必须有初值。</p><h2 id="6-3-匿名对象"><a href="#6-3-匿名对象" class="headerlink" title="6.3 匿名对象"></a>6.3 匿名对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">phone</span>().sendEmail();<span class="comment">//创建一个对象，但没有显示的赋给一个对象名，调用完方法就无法使用了。</span></span><br></pre></td></tr></table></figure><h2 id="6-4-方法"><a href="#6-4-方法" class="headerlink" title="6.4 方法"></a>6.4 方法</h2><h3 id="6-4-1-方法的重载"><a href="#6-4-1-方法的重载" class="headerlink" title="6.4.1 方法的重载"></a>6.4.1 方法的重载</h3><p>重载：一些重名的方法</p><p>​同一个类，相同的方法名；</p><p>​参数列表不同，参数个数不同，参数类型不同；</p><h3 id="6-4-2-可变个数的形参"><a href="#6-4-2-可变个数的形参" class="headerlink" title="6.4.2 可变个数的形参"></a>6.4.2 可变个数的形参</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> num,String...strs)</span>&#123;<span class="comment">//传入任意个数的String类型参数（可以为0个），可变类型形参只能有一个，且只能在参数列表末尾。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.length;++i)&#123;</span><br><span class="line">        strs[i];<span class="comment">//遍历所有参数（strs就相当于一个变长数组）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5-变量赋值"><a href="#6-5-变量赋值" class="headerlink" title="6.5 变量赋值"></a>6.5 变量赋值</h2><p>基本数据类型：值传递</p><p>引用数据类型：地址传递</p><h2 id="6-6-封装性"><a href="#6-6-封装性" class="headerlink" title="6.6 封装性"></a>6.6 封装性</h2><p>类属性私有化(private),提供公共的属性(public)来获取或者设置该属性。</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071538920.png" alt="image-20230707153832792"></p><p><span style="background:yellow">类只能用缺省和public修饰</span></p><h2 id="6-7-构造器"><a href="#6-7-构造器" class="headerlink" title="6.7 构造器"></a>6.7 构造器</h2><p>​一个类中多个构造器构成重载；</p><p>​构造方法没有返回类型，但是有返回值，返回的就是一个对象，可以有访问权限修饰符，但是不能有static final之类的修饰符</p><ul><li><font color="blue">空参构造器</font><ol><li>子类继承时，默认调用super()空参</li><li>便于反射时创建运行时类对象</li></ol></li></ul><h2 id="6-8-UML类图"><a href="#6-8-UML类图" class="headerlink" title="6.8 UML类图"></a>6.8 UML类图</h2><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071540885.png" alt="image-20230707154016760"></p><h2 id="6-9-this"><a href="#6-9-this" class="headerlink" title="6.9 this"></a>6.9 this</h2><p>this即是当前对象，可以调用当前类的属性和方法。</p><h2 id="6-10-package和import"><a href="#6-10-package和import" class="headerlink" title="6.10 package和import"></a>6.10 package和import</h2><ul><li><p>package</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071554853.png" alt="image-20230707155422719"></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071554084.png" alt="image-20230707155449936"></p></li><li><p>import</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071555828.png" alt="image-20230707155510691"></p></li></ul><h2 id="6-11-继承"><a href="#6-11-继承" class="headerlink" title="6.11 继承"></a>6.11 继承</h2><ul><li>extends</li><li>一个类可以被多个类继承，一个类只能有一个父类（单继承性）</li><li>光标放到类名，CTRL+T 可以看到继承结构</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(parameter)</span>&#123;<span class="comment">//构造器</span></span><br><span class="line">        <span class="comment">//如果子类构造方法的声明没有明确调用父类的构造方法，则系统在执行子类构造方法时会自动调用父类的默认构造方法（即无参数构造方法）。</span></span><br><span class="line"></span><br><span class="line">　　   <span class="comment">//如果想调用一个带参数的父类构造方法，就必须用关键字super显示地编写构造方法语句。</span></span><br><span class="line">        <span class="built_in">super</span>(parameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-11-1-方法的重写"><a href="#6-11-1-方法的重写" class="headerlink" title="6.11.1 方法的重写"></a>6.11.1 方法的重写</h3><p>子类继承父类，对同名同参的方法，进行覆盖操作；</p><p>不能重写父类的private方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span><span class="comment">//表明以下方法是重写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-11-2-super"><a href="#6-11-2-super" class="headerlink" title="6.11.2 super"></a>6.11.2 super</h3><p>显式的调用父类的方法</p><p>super.属性</p><p>super.方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在构造器中，以下两种只能二选一（因为他们都必须在构造器的首行）</span></span><br><span class="line"><span class="built_in">this</span>(形参列表);</span><br><span class="line"><span class="built_in">super</span>(形参列表);</span><br></pre></td></tr></table></figure><h2 id="6-12-多态"><a href="#6-12-多态" class="headerlink" title="6.12 多态"></a>6.12 多态</h2><ol><li><p>对象的多态性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类的引用指向子类的对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//也叫虚拟方法调用</span></span><br><span class="line">p.method();<span class="comment">//调用的是子类的方法（有重写的情况下）</span></span><br><span class="line">p.参数;<span class="comment">//只能调用Person类的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//虽然参数类型是Person，但可以传入其子类对象Man，调用的当然也是子类的方法，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">    p.method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><span style="background:yellow">多态和重载的区别</span></li></ul><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071559917.png" alt="image-20230707155909774"></p><p><span style="background:yellow">多态是运行时行为</span></p></li><li><p>instanceof</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> A<span class="comment">//判断实列对象a是否是类A的一个实列，是返回true，不是返回false</span></span><br><span class="line"></span><br><span class="line">A可以是父类，也可以是间接父类，都会返回<span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="6-13-Object类"><a href="#6-13-Object类" class="headerlink" title="6.13 Object类"></a>6.13 Object类</h2><h3 id="6-13-1-equal和"><a href="#6-13-1-equal和" class="headerlink" title="6.13.1 equal和&#x3D;&#x3D;"></a>6.13.1 equal和&#x3D;&#x3D;</h3><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071602820.png" alt="image-20230707160204682"></p><p>比如说比较String，就要用equals()，&#x3D;&#x3D;比较的是地址，不同的String肯定不会相等，而equals是重写过的，比较的是字符串的每一个字符是否都相等。</p><h3 id="6-13-2-toString"><a href="#6-13-2-toString" class="headerlink" title="6.13.2 toString()"></a>6.13.2 toString()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(object);</span><br></pre></td></tr></table></figure><p>执行过程中调用对象内部的toString方法</p><h2 id="6-14-单元测试"><a href="#6-14-单元测试" class="headerlink" title="6.14 单元测试"></a>6.14 单元测试</h2><p>就相当于写了一个Public void无参函数，可以单独执行这个函数，从而测试这个函数体类的相关代码。</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071836884.png" alt="image-20230707183620733"></p><h2 id="6-15-包装类-Wrapper"><a href="#6-15-包装类-Wrapper" class="headerlink" title="6.15 包装类(Wrapper)"></a>6.15 包装类(Wrapper)</h2><table><thead><tr><th align="center">基本数据类型</th><th align="center">包装类</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td></tr><tr><td align="center">char</td><td align="center">Character</td></tr></tbody></table><ul><li><p>基本数据类型、包装类、和string之间的转换</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307071840158.png" alt="image-20230707184026001"></p></li><li><p>新特性，自动装箱与自动拆箱<span style="background:yellow">（只适用于基本数据类型和包装类）</span></p></li></ul><h2 id="6-16-static"><a href="#6-16-static" class="headerlink" title="6.16 static"></a>6.16 static</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态变量（也叫类变量）随着类的加载而加载</span></span><br><span class="line"><span class="comment">//通过某一对象修改，其他对象也会改变</span></span><br><span class="line"><span class="comment">//可以通过类调用</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法只能调用静态属性和方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h2 id="6-17-代码块"><a href="#6-17-代码块" class="headerlink" title="6.17 代码块"></a>6.17 代码块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mmm</span>&#123;</span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>静态代码块</li></ol><ul><li><p>内部可以有输出语句</p></li><li><p>﻿随着类的加载而执行，而且只执行一次</p></li><li><p>作用：初始化类的信息</p></li><li><p>﻿如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</p></li><li><p>﻿静态代码块的执行要优先于非静态代码块的执行</p></li><li><p>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</p></li></ul><ol start="2"><li>非静态代码块</li></ol><ul><li><p>内部可以有输出语句</p></li><li><p>随着对象的创建而执行</p></li><li><p>每创建一个对象，就执行一次非静态代码块</p></li><li><p>作用：可以在创建对象时，对对象的属性等选行初始化</p></li><li><p>如果一个类中定义了多个非静态代码块，则按昭声明的先后顺序执行</p></li><li><p>非楼态代码块內可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</p></li></ul><p><span style="background:yellow">要理解清楚静态的只有类，还没有对象</span></p><h2 id="6-18-final"><a href="#6-18-final" class="headerlink" title="6.18 final"></a>6.18 final</h2><ol><li>final可以用来修饰的结构：类、方法、变量</li><li>﻿﻿﻿final 用来修饰一个类：此类不能被其他类所继承<br> 比如： String、System类、StringBuffer类</li><li>final 用来修饰方法，表明此方法不可以被重写<br> 比如Object类中getClass()</li><li>﻿﻿﻿final 用来修饰变量，此时的“变量“就称为是一个常量<ol><li>final修饰属性，可以考虑赋值的位置有，显式初始化、代码块中初始化、构造器中初始化</li><li>final修饰局部变量<br> 尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋值一个实参，就只能在方法体内使用此形参，但不能对其重新赋值</li></ol></li></ol><h2 id="6-19-匿名类"><a href="#6-19-匿名类" class="headerlink" title="6.19 匿名类"></a>6.19 匿名类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//一个抽象类Peron</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名子类对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="comment">//重写所有抽象方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名子类匿名对象</span></span><br><span class="line">method(<span class="keyword">new</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="comment">//重写所有抽象方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-20-抽象类"><a href="#6-20-抽象类" class="headerlink" title="6.20 抽象类"></a>6.20 抽象类</h2><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能共享特征。有时将一个父类设计得非常抽象，以至手它没有具体的实例，这样的类叫做抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">name</span>&#123;</span><br><span class="line">    <span class="comment">//用abstract修饰的类就不能被实例化了</span></span><br><span class="line">    <span class="comment">//抽象方法，没有方法实体，只有抽象类才能创建抽象方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>abstract只能修饰类和方法</p><ol><li>abstract修饰类：抽象类</li></ol><ul><li><p>此类不能实例化</p></li><li><p>抽象类中一定有构造器，便于子类实例化时调用(涉及：子类对象实例化的全过程）</p></li><li><p>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</p></li></ul><ol start="2"><li>abstract俊饰方法：抽象方法</li></ol><ul><li><p>抽象方法只有方法的声明，没有方法体</p></li><li><p>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</p></li><li><p>若子类重写了父类中的所有的抽象方法后，此子类方可实例化</p></li><li><p>若子类没有重写父类中的所有的抽象方法，则子类也是一个抽象类，需要使用abstract修饰</p></li></ul><h2 id="6-21-接口"><a href="#6-21-接口" class="headerlink" title="6.21 接口"></a>6.21 接口</h2><ol><li><p>接口使用interface来定义</p></li><li><p>java中，接口和类是并列的两个结构</p></li><li><p>如何定义接口：定义接口中的成员</p><ol><li>JDK7及以前：只能定义全局常量和抽象方法<ul><li>全局常量：<code>public static final</code>修饰的。但是书写时，可以省略不写</li><li>抽象方法：<code>public abstract</code>修饰</li></ul></li></ol></li><li><p>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略）</p></li><li><p>接口中不能定义构造器的！意味着接口不可以实例化</p></li><li><p>java开发中，接口通过让类去实现(implements)的方式来使用，如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化，如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</p></li><li><p>﻿﻿﻿java类可以实現多个接口 —&gt;弥补了java单继承性的局限性</p><p><code>class AA extends BB implements CC, DD,EE</code></p><p>接口与接口之间可以继承，而且可以多继承,接口的县体使用，体现多态性</p></li></ol><p>JDK8新特性：除了定义全局常量和抽象方法外，还可以定义<span style="background:yellow">静态方法</span>和<span style="background:yellow">默认方法</span></p><ol><li>接口中定义的静态方法，只能通过接口名来调用，其实现类的对象不能调用</li><li>而实现类的对象可以调用接口中的默认方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClothFactory</span> &#123;</span><br><span class="line">    <span class="comment">//全局常量</span></span><br><span class="line">    <span class="type">int</span> MM=<span class="number">10</span>;</span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-22-内部类"><a href="#6-22-内部类" class="headerlink" title="6.22 内部类"></a>6.22 内部类</h2><ol><li><p>Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类</p></li><li><p>内部类的分类，成员内部类(静忘，非静态） VS 局部内部类（方法内，代码块内、构造器内）</p></li></ol><ul><li>成员内部类（作为类的属性成员）</li></ul><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081005968.png" alt="image-20220404212517336"></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081005142.png" alt="image-20220404213012685"></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081005715.png" alt="image-20220404213130679"></p><ul><li>局部内部类（方法内或者代码块内）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="comment">// 局部内部类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-设计模式"><a href="#7-设计模式" class="headerlink" title="7. 设计模式"></a>7. 设计模式</h1><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081012308.png" alt="image-20220328173414182"></p><h2 id="7-1-单例设计模式"><a href="#7-1-单例设计模式" class="headerlink" title="7.1 单例设计模式"></a>7.1 单例设计模式</h2><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081012313.png" alt="image-20220328173434845"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="comment">//私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内部创建类的对象</span></span><br><span class="line">    <span class="comment">//要求此对象也必须声明为静态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="comment">//提供公共的静态的方法，返回对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外部创建对象，即使再创建一个也是同一个对象</span></span><br><span class="line"><span class="type">Bank</span> <span class="variable">bank1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//提供公共的静态的方法，返回对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式：1. 对象加载时间过长</p><p>​   2. 线程安全的</p><p>懒汉式：1. 延迟对象的创建</p><p>​   2.可能存在线程不安全的情况</p><h2 id="7-2-模板方法的设计模式"><a href="#7-2-模板方法的设计模式" class="headerlink" title="7.2 模板方法的设计模式"></a>7.2 模板方法的设计模式</h2><p>抽象类的应用：模板方法的设计模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BankTemplateMethod</span>&#123;</span><br><span class="line">    <span class="comment">//具体方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeNumber</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">transact</span><span class="params">()</span>;<span class="comment">//办理具体的业务，钩子方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evaluate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模板方法，把基本操作组合到一起，子类一般不能重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.takeNumber();</span><br><span class="line">        <span class="built_in">this</span>.transact();<span class="comment">//像个钩子，具体执行时，挂哪个子类就执行哪</span></span><br><span class="line">        <span class="built_in">this</span>.evaluate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrawMoney</span> <span class="keyword">extends</span> <span class="title class_">BankTemplateMethod</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transact</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//取款</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ManageMoney</span> <span class="keyword">extends</span> <span class="title class_">BankTemplateMethod</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transact</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//理财</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line"><span class="comment">//根据创建对象的不同执行不同的功能</span></span><br><span class="line"><span class="type">BankTemplateMethod</span> <span class="variable">btm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DrawMoney</span>();</span><br><span class="line">btm.process();</span><br><span class="line"></span><br><span class="line"><span class="type">BankTemplateMethod</span> <span class="variable">btm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ManageMoney</span>();</span><br><span class="line">btm.process();</span><br></pre></td></tr></table></figure><h2 id="7-3-代理模式"><a href="#7-3-代理模式" class="headerlink" title="7.3 代理模式"></a>7.3 代理模式</h2><p>接口的应用：代理模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现网络访问的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> <span class="keyword">implements</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">//真实实现访问网络</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类(调用被代理类的一个过程)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyServer</span> <span class="keyword">implements</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NetWork work;</span><br><span class="line">    ProxyServer(NetWork work)&#123;</span><br><span class="line">        <span class="built_in">this</span>.work = work;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他自己的工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span>&#123;</span><br><span class="line">         chech();</span><br><span class="line">         work.browse();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态代理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyClothFactory</span> <span class="variable">proxyClothFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyClothFactory</span>(<span class="keyword">new</span> <span class="title class_">NikeClothFactory</span>());</span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyClothFactory</span> <span class="keyword">implements</span> <span class="title class_">ClothFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ClothFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入的是实现了ClothFactory接口的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyClothFactory</span><span class="params">(ClothFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些准备工作&quot;</span>);</span><br><span class="line">        factory.produceCloth();</span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些收尾工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeClothFactory</span> <span class="keyword">implements</span> <span class="title class_">ClothFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;NIKE工厂生产一批运动服&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ClothFactory</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-4-工厂模式"><a href="#7-4-工厂模式" class="headerlink" title="7.4 工厂模式"></a>7.4 工厂模式</h2><h3 id="7-4-1-简单工厂"><a href="#7-4-1-简单工厂" class="headerlink" title="7.4.1 简单工厂"></a>7.4.1 简单工厂</h3><ul><li>设计</li></ul><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081256406.png" alt="image-20220403113642103"></p><ul><li>使用</li></ul><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081256980.png" alt="image-20220403113751335"></p><h3 id="7-4-2-工厂方法"><a href="#7-4-2-工厂方法" class="headerlink" title="7.4.2 工厂方法"></a>7.4.2 工厂方法</h3><h3 id="7-4-3-抽象工厂"><a href="#7-4-3-抽象工厂" class="headerlink" title="7.4.3 抽象工厂"></a>7.4.3 抽象工厂</h3><h1 id="8-异常处理"><a href="#8-异常处理" class="headerlink" title="8. 异常处理"></a>8. 异常处理</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><p>Throwable异常分类：</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081258430.png" alt="image-20220405101530020"></p><p>Exception：编译时异常&amp;&amp;运行时异常(RuntimeException)</p><ul><li><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081259345.png" alt="image-20220603152251863"></li></ul><h2 id="8-2-异常处理机制"><a href="#8-2-异常处理机制" class="headerlink" title="8.2 异常处理机制"></a>8.2 异常处理机制</h2><ol><li>try-catch-finally 注意：try-catch-finally 以下的代码会照样执行而try中发生异常之后的代码不执行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能会出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型名<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型名<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//一定会执行的代码，可以不写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081302248.png" alt="image-20220729153107515"></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081302451.png" alt="image-20220405172603402"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.getMessage();<span class="comment">//返回一个错误信息的字符串</span></span><br><span class="line">e.printStackTrace();<span class="comment">//打印错误相关信息，红的红的</span></span><br></pre></td></tr></table></figure><ol start="2"><li>throws</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法可能会抛两个异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> <span class="keyword">throws</span> Excp1,Excp2&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081311651.png" alt="image-20220405180203815"></p></li><li><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081311264.png" alt="    "></p></li><li><p><span style="background:yellow">子类重写父类方法时，抛出的异常应该比父类的异常同级或者是其子类，这样在某些多态条件下才能catch住这个给异常</span></p></li></ul><h2 id="8-3-生成异常"><a href="#8-3-生成异常" class="headerlink" title="8.3 生成异常"></a>8.3 生成异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成一个异常，同样可以用catch和throw方式进行处理</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;message&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="8-4-自定义异常类"><a href="#8-4-自定义异常类" class="headerlink" title="8.4 自定义异常类"></a>8.4 自定义异常类</h2><p>一般继承两个异常 Exception（编译时就要考虑的异常）和RuntimeException（运行时异常）</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081314126.png" alt="image-20220410160948920"></p><h1 id="9-多线程"><a href="#9-多线程" class="headerlink" title="9. 多线程"></a>9. 多线程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java.lang.Thread <span class="comment">//多线程类</span></span><br></pre></td></tr></table></figure><h2 id="9-1-多线程的创建"><a href="#9-1-多线程的创建" class="headerlink" title="9.1 多线程的创建"></a>9.1 多线程的创建</h2><ul><li>Tread类方法</li></ul><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081329870.png" alt="image-20220422143429958"></p><ul><li><p>设置优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myThread.setPriority(Thread.MAX_PRIORITY)</span><br></pre></td></tr></table></figure></li><li><p>线程创建方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//带参构造器，可以设置线程名字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//run()里写的是我们这个线程需要执行的语句</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">20</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                Thread.<span class="keyword">yield</span>();<span class="comment">//释放当前进程的执行权（当然下一刻又可能重新分配给他）</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);<span class="comment">//当前进程阻塞1000ms</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Start</span> &#123;</span><br><span class="line">    <span class="comment">//主线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();            myThread.setPriority(Thread.MAX_PRIORITY);<span class="comment">//线程开始之前可以设置优先级</span></span><br><span class="line">        myThread.start();<span class="comment">//启动myThread线程；并调用当前线程的run方法；一个线程只能start一次</span></span><br><span class="line">        myThread.run();<span class="comment">//不是多线程，只是执行这个方法</span></span><br><span class="line">        <span class="comment">//如果这里再写其他输出语句，此时是主线程，就会和上面的myThread交替输出（并行）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建线程方法二：</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081331982.png" alt="image-20220422155855127"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImplementRunnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多个线程可以共用这个对象，适合多个线程有共享数据的情况</span></span><br><span class="line">        <span class="type">ImThread</span> <span class="variable">imThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(imThread);</span><br><span class="line">        thread_1.setName(<span class="string">&quot;thread_1&quot;</span>);</span><br><span class="line">        thread_1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread_2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(imThread);</span><br><span class="line">        thread_2.setName(<span class="string">&quot;thread_2&quot;</span>);</span><br><span class="line">        thread_2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//一般来说只造一个对象，所以声明一个private类型的属性就行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;<span class="comment">//共享数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//方便查看线程交错执行的情况，每次该线程阻塞100ms</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 输出 &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>两者不同：</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081333821.png" alt="image-20220422160842113"></p></li><li><p>创建线程方法三：&#x3D;&#x3D;可以抛异常，且有返回值，支持泛型&#x3D;&#x3D;</p><p>实现Callable接口</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081334361.png" alt="image-20220423173131184"></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081334513.png" alt="image-20220423173335621"></p></li><li><p>创建线程方法四：线程池</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081335679.png" alt="image-20220711155526895"></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081336758.png" alt="image-20220423172958847"></p></li></ul><h2 id="9-2-生命周期"><a href="#9-2-生命周期" class="headerlink" title="9.2 生命周期"></a>9.2 生命周期</h2><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081337408.png" alt="image-20220422180747065"></p><h2 id="9-3-线程同步"><a href="#9-3-线程同步" class="headerlink" title="9.3 线程同步"></a>9.3 线程同步</h2><ul><li><p>方法一:同步代码块</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081339978.png" alt="image-20220422181706722"></p><p>继承Thread类的实现中，同步监视器可用  &#x3D;&#x3D;类名.class&#x3D;&#x3D;</p><p>实现Runnable接口，同步监视器可用&#x3D;&#x3D;this&#x3D;&#x3D; 因为一般只new一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖票  票号为: &quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二：同步方法</p><p>如果操作共享数据的代码完整的声明在一个方法中，不妨将此方法声明为同步方法</p><p>&#x3D;&#x3D;注意：&#x3D;&#x3D;run()方法不能用synchronized修饰</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081340880.png" alt="image-20220708230917309"></p><ul><li><p>实现runnable的使用，用同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把操作临界区的方法设置为synchronized的，监视器默认为this（所以对于实现Thread的方式来说是不安全的，他一般会造几个对象，this就不唯一了）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">synchronized</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Thread的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法设置为静态,监视器为当前类(类名.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">synchronized</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>方法三：同步锁</p><p>JDK5.0开始，更强大的线程同步机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    临界区</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//设置一个同步锁，true表示先来的进程会优先得到临界资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//临界代码用try/finally包围</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;买票，票号为： &quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>例题 一个账户两个储户：两个储户分别向这个账户存3000，每次存1000，存3次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;储户一&quot;</span>);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer_2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;储户二&quot;</span>);</span><br><span class="line">        customer_1.start();</span><br><span class="line">        customer_2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">        balance += money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为每个顾客都有自己的属性balance，所以用继承Thread的方式创建3个顾客进程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Account</span> <span class="variable">act</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">3000</span>;</span><br><span class="line">    <span class="comment">//注意同步锁的唯一性，这里创建了2个对象，所以加static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (balance &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    act.deposit(<span class="number">1000</span>);</span><br><span class="line">                    balance -= <span class="number">1000</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 存钱:1000 &quot;</span> + <span class="string">&quot;账户余额为：&quot;</span> + act.getBalance());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-4-死锁"><a href="#9-4-死锁" class="headerlink" title="9.4 死锁"></a>9.4 死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p><h2 id="9-5-线程通信"><a href="#9-5-线程通信" class="headerlink" title="9.5 线程通信"></a>9.5 线程通信</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wait();<span class="comment">//执行该代码的线程进入阻塞状态  并释放锁</span></span><br><span class="line">notifyAll();<span class="comment">//唤醒所有阻塞进程</span></span><br></pre></td></tr></table></figure><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307081406530.png" alt="image-20220423160411420"></p><p>&#x3D;&#x3D;只能用在同步代码块和同步方法（lock不能用这个进行通信），因为这三个方法的调用对象只能是同步监视器对象，lock没有同步监视器&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="comment">//唤醒另一个优先级最高的进程，当前进程还握有锁，其他进程也不能进入</span></span><br><span class="line">                <span class="built_in">this</span>.notify();</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + num);</span><br><span class="line">                    num++;</span><br><span class="line">                    <span class="comment">//当前进程进入阻塞状态，并释放同步锁（注意：Sleep是不会释放锁的）</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-String类"><a href="#10-String类" class="headerlink" title="10. String类"></a>10. String类</h1><h2 id="10-0-编码"><a href="#10-0-编码" class="headerlink" title="10.0 编码"></a>10.0 编码</h2><ul><li><p>最早的美国ASCII编码一个字节就能表示数字，字母等。首位没用，就用了后7位来表示</p></li><li><p>后来计算机技术传入其它国家，有新的编码方式GBK等；它是向下兼容的</p><p>仍用一个字节表示原来的ASCII字符，其它的如，汉字就用两个字节表示，字节首个二进制0代表一个字节表示，1代表2个字节表示</p></li><li><p>ANSI：平台默认编码。英文操作系统中是ISO-8859-1，中文系统是GBK</p></li><li><p>Unicode只是定义了一个庞大的，全球通用的字符集，并为每个字符确定了唯一确定的编号，具体存为什么样的字符流，取决于字符编码方案，推荐的Unicode编码为UTF-8，UTF-16（即每次传输8，16个二进制位）</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307092307418.png" alt="image-20220727164400881"></p><p>如上图，同样用首位来确定几位编码，汉字用了3个字节</p></li></ul><h2 id="10-1-String"><a href="#10-1-String" class="headerlink" title="10.1 String"></a>10.1 String</h2><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307092307230.png" alt="image-20220507095851038"></p><p>字符串的不可变性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面量的定义方式，此时字符串值声明在字符串常量池中</span></span><br><span class="line"><span class="comment">//字符串常量池不会存储相同的内容的字符串</span></span><br><span class="line"><span class="comment">//此时s1 == s2</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//new的方式开辟的在内存的堆区</span></span><br><span class="line"><span class="comment">//s1 != s2</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;www&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;www&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//涉及到变量的拼接那么就会在堆区开辟内存</span></span><br><span class="line"><span class="comment">//当然如果s1是final修饰的，那还是在常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + <span class="string">&quot;eee&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307092308649.png" alt="image-20220505175338063"></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307092309014.png" alt="image-20220506215212473"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串转换为字符数组</span></span><br><span class="line"><span class="type">char</span>[] charArray = str.toCharArray();   </span><br><span class="line"><span class="comment">//字符数组转换为字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//转换为字节数组</span></span><br><span class="line"><span class="type">byte</span>[] byt = str.getBytes(charsetName:<span class="string">&quot;gbk&quot;</span>);<span class="comment">//转换为字节数组并指定编码方式</span></span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(byt,charsetName:<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"></span><br><span class="line">昝荣华 <span class="comment">//UTF_8汉字是3个字节</span></span><br><span class="line">[-<span class="number">26</span>, -<span class="number">104</span>, -<span class="number">99</span>, -<span class="number">24</span>, -<span class="number">115</span>, -<span class="number">93</span>, -<span class="number">27</span>, -<span class="number">115</span>, -<span class="number">114</span>]</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="10-2-StringBuffer"><a href="#10-2-StringBuffer" class="headerlink" title="10.2 StringBuffer"></a>10.2 StringBuffer</h2><p>默认容量是初始容量+16，超过之后会在底层重新new一个字符数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定容量的buffer</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307092310603.png" alt="image-20220507111442413"></p><h2 id="10-3-StringBuilder"><a href="#10-3-StringBuilder" class="headerlink" title="10.3 StringBuilder"></a>10.3 StringBuilder</h2><p>同StringBuffer，效率更高，但不是线程安全的；</p><h2 id="10-4-Java比较器"><a href="#10-4-Java比较器" class="headerlink" title="10.4 Java比较器"></a>10.4 Java比较器</h2><ul><li>comparable</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">compareable接口;</span><br><span class="line"><span class="comment">//自然排序</span></span><br><span class="line"><span class="comment">//自定义类要实现排序，需要继承compareable接口，重写compareTo接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内部实现Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;   </span><br><span class="line">    <span class="keyword">private</span> String ID; </span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; </span><br><span class="line">    <span class="keyword">private</span> Double score; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student arg0)</span> &#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">    <span class="comment">// 此种写法为升序，若改为arg0.ID.compareTo(this.ID)则为降序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.ID.compareTo(arg0.ID); </span><br><span class="line">        <span class="comment">//return this.ID - arg0.ID;</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>comparator</li></ul><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307101458524.png" alt="image-20220510171556772"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定制排序</span></span><br><span class="line"><span class="comment">//实现comparator接口，重写compare方法</span></span><br><span class="line">Arrays.sort(arr,<span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(object o1,object o2)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 按姓名进行升序排序的外部类，用Comparator接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComparatorWithNameUP</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student arg0, Student arg1)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> arg0.getName().compareTo(arg1.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-4-正则表达式"><a href="#10-4-正则表达式" class="headerlink" title="10.4 正则表达式"></a>10.4 正则表达式</h2><ul><li><strong>主要类及其使用方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;砸金花1998和时间256莎莎看哈萨克156874啥叫和.&quot;</span>;</span><br><span class="line"><span class="comment">//正则表达式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="string">&quot;(\\d\\d)(\\d\\d)&quot;</span>;<span class="comment">//括号进行分组</span></span><br><span class="line"><span class="comment">//创建模式</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(reg);</span><br><span class="line"><span class="comment">//字符串s中去匹配正则</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(s);</span><br><span class="line"><span class="comment">//每次匹配一个,如果能匹配到,matcher.find()返回为True。匹配到的内容在group中,</span></span><br><span class="line"><span class="keyword">while</span> (matcher.find())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> matcher.group(<span class="number">0</span>);<span class="comment">//所有</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> matcher.group(<span class="number">1</span>);<span class="comment">//第一组</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> matcher.group(<span class="number">2</span>);<span class="comment">//第二组</span></span><br><span class="line">    System.out.println(s1+<span class="string">&quot; &quot;</span>+s2+<span class="string">&quot; &quot;</span>+s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用Pattern类的静态方法判断字符串s是否整体匹配成功</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isMatch</span> <span class="operator">=</span> Pattern.matches(reg,s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Matcher类</span></span><br><span class="line">matcher.start();<span class="comment">//每次匹配到的开始索引</span></span><br><span class="line">matcher.end();<span class="comment">//每次匹配到的结束索引，参数里可以指定分组</span></span><br><span class="line"><span class="type">String</span> <span class="variable">nStr</span> <span class="operator">=</span> matcher.replaceAll(<span class="string">&quot;newString&quot;</span>);<span class="comment">//替换所有</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>正则转义符</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="string">&quot;\\.&quot;</span>;<span class="comment">//匹配一个字符&#x27;.&#x27; ,两个\\表示转义</span></span><br></pre></td></tr></table></figure></li><li><p><strong>字符匹配</strong>（大写表示取反）</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307101716679.png" alt="image-20220604231838045"></p><p>👆都是要加[]的</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307101716505.png" alt="image-20220604231940991"></p><p>\\s匹配任何空白字符（空格，制表符）</p><p>\\S匹配任何非空白字符</p></li><li><p>大小写问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(?i)abc <span class="comment">//abc不区分大小写</span></span><br><span class="line">a(?i)bc <span class="comment">//bc不区分大小写</span></span><br><span class="line">a((?i)b)c <span class="comment">//b不区分大小写</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//创建模式时参数Pattern.CASE_INSENSITIVE不区分大小写</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(reg,Pattern.CASE_INSENSITIVE);</span><br></pre></td></tr></table></figure></li><li><p><strong>选择匹配符</strong></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307101716835.png" alt="image-20220605105226540"></p></li><li><p><strong>限定符</strong></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307101716080.png" alt="image-20220605140306271"></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307101716420.png" alt="image-20220605140902595"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;a&#123;2,3&#125;&quot;</span> <span class="comment">//表示匹配aa 或者aaa 贪婪匹配，优先匹配多的即aaa</span></span><br></pre></td></tr></table></figure></li><li><p><strong>定位符</strong></p><p>指定在原字符串的那个位置进行匹配</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307101716564.png" alt="image-20220605143251482"></p></li><li><p><strong>分组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="string">&quot;(\\d\\d)(\\d\\d)&quot;</span>; <span class="comment">//分组0，1，2</span></span><br><span class="line"><span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="string">&quot;(?&lt;g1&gt;\\d\\d)(?&lt;g2&gt;\\d\\d)&quot;</span>; <span class="comment">//分组命名</span></span><br></pre></td></tr></table></figure></li><li><p><strong>非捕获分组</strong></p><p>就是加了括号，但表示的不是分组，不能用group(1)这样去获取</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307101716964.png" alt="image-20220605144440907"></p></li><li><p><strong>非贪婪匹配</strong></p><p>默认贪婪匹配。后面加个?表示非贪婪匹配，即尽量匹配少的</p></li><li><p><strong>反向引用</strong></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307101717511.png" alt="image-20220605154700126"></p><p>内部反向引用：正则表达式内使用的。</p><p>例：<img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307101717484.png" alt="image-20220605155216957"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反向引用案例：结巴去重</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;我我我...要要..学学学....java&quot;</span>;</span><br><span class="line"><span class="comment">//反向引用，能匹配到 我我我 ... 要要 .. 学学学 .... </span></span><br><span class="line"><span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="string">&quot;(.)\\1+&quot;</span>;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(reg);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(s);</span><br><span class="line"><span class="comment">//在外面把匹配到的替换成 反向引用的那个（外部反向引用）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> matcher.replaceAll(<span class="string">&quot;$1&quot;</span>);</span><br><span class="line"><span class="comment">//去除.</span></span><br><span class="line">System.out.println(s1.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure></li></ul><h1 id="11-枚举类"><a href="#11-枚举类" class="headerlink" title="11. 枚举类"></a>11. 枚举类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line">自己写的普通类，是继承于Object类的</span><br><span class="line">pass;</span><br><span class="line"></span><br><span class="line"><span class="comment">//enum关键字定义枚举类</span></span><br><span class="line"><span class="comment">//使用enum关键字默认继承于java.lang.Enum</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    <span class="comment">//通过构造器构造的枚举类对象，只不过省略了前面的public staic final .. = new()</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春天好啊&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏天好啊&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋天好啊&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冬天好啊&quot;</span>);</span><br><span class="line">    <span class="comment">//枚举类的属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    Season(String seasonName,String seasonDesc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName=seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc=seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一般不重写toString方法，默认是SPRING..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> Season.SPRING;</span><br></pre></td></tr></table></figure><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307101719579.png" alt="image-20220508212226576"></p><h1 id="12-注解"><a href="#12-注解" class="headerlink" title="12 注解"></a>12 注解</h1><p>Annotation</p><p>框架 &#x3D; 注解 + 反射+ 设计模式</p><ul><li>JDK内置的三个注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//方法重写，编译时会进行校验</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="comment">//此方法已过时，不建议使用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span></span><br><span class="line"><span class="comment">//抑制变量未使用警告</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="comment">//抑制变量未使用警告and未加泛型警告</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unused&quot;,&quot;rawtypes&quot;&#125;)</span></span><br></pre></td></tr></table></figure><ul><li><p>自定义注解</p><p>框架的时候再学（根据反射来实现对应注解的功能）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    <span class="comment">//定义内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span> &#123;</span><br><span class="line">    <span class="comment">//注解可以显示赋值，如果没有默认值，则必须赋值</span></span><br><span class="line">    <span class="meta">@MyAnnotation1(age = 25)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@MyAnnotation2(&quot;value&quot;)</span><span class="comment">//只有一个参数可以省略参数名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span><span class="comment">//没有参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation1&#123;</span><br><span class="line">    <span class="comment">//注解的参数：参数类型+参数名+（）</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;<span class="comment">//-1代表不存在</span></span><br><span class="line">    String[] schools() <span class="keyword">default</span> &#123;<span class="string">&quot;武汉理工大学&quot;</span>,<span class="string">&quot;南京师范大学&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation2&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;<span class="comment">//只有一个参数名字约定用value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>元注解</p><p>即修饰注解的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>  用于描述注解的使用范围，修饰的是类，方法，还是其它;</span><br><span class="line"><span class="meta">@Rentenion</span>  用于描述注解的生命周期，即什么时候有效;</span><br><span class="line">SOURCE&lt;CLASS&lt;RUNTIME 源代码时&lt;编译成类时&lt;运行时</span><br></pre></td></tr></table></figure></li></ul><h1 id="13-集合"><a href="#13-集合" class="headerlink" title="13. 集合"></a>13. 集合</h1><ul><li><p>无论是Collection还是Map的对象一定要重写equals()方法  {无论是否可重复，删除的时候一定会调用equals方法}</p></li><li><pre><code class="java">//向上转型，Collection list只能使用自己的方法，不能使用ArrayList的方法Collection list = new ArrayList();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- ![image-20220509103112231](https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307101725981.png)</span><br><span class="line"></span><br><span class="line">## 13.1 Collection</span><br><span class="line"></span><br><span class="line">![Collection](https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307101724602.png)</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">//Collection常用方法</span><br><span class="line"></span><br><span class="line">Collection list = new ArrayList();</span><br><span class="line">++++++++++++++++++++</span><br><span class="line">list.add(Object);//添加元素</span><br><span class="line"></span><br><span class="line">//判断是否包含元素  contains调用的是equal方法</span><br><span class="line">boolean contains = list.contains(1);//True</span><br><span class="line"></span><br><span class="line">list.containsAll(list1);//判断list1中的所有元素是不是都被包含</span><br><span class="line"></span><br><span class="line">list.remove(1);//移除</span><br><span class="line"></span><br><span class="line">list.removeAll(list1);//移除所有元素</span><br><span class="line"></span><br><span class="line">list.retainAll(list1);//返回两个集合交集中的部分</span><br><span class="line"></span><br><span class="line">Object[] arr = list.toArray();//集合转换为数组</span><br></pre></td></tr></table></figure></code></pre></li><li><p>集合的遍历</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//集合的遍历</span></span><br><span class="line">System.out.println(list);<span class="comment">//[object1,object2,...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Iterator的三个方法</span></span><br><span class="line">hasNext();</span><br><span class="line">next();</span><br><span class="line">remove();</span><br><span class="line"></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();<span class="comment">//获取迭代器对象</span></span><br><span class="line"><span class="comment">//每次调用list.iterator()都会获得指向开头的一个指针</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());<span class="comment">//从头开始获取下一个元素</span></span><br><span class="line">    iterator.remove();<span class="comment">//在遍历的时候删除元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//foreach 内部也是iterator</span></span><br><span class="line"><span class="keyword">for</span>(Object o:list)&#123;</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部迭代</span></span><br><span class="line">list1.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="13-1-1-List"><a href="#13-1-1-List" class="headerlink" title="13.1.1 List"></a>13.1.1 List</h3><p>有序，支持索引</p><ul><li><p><strong>List方法（有序，可重复）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arr类型不能为基本数据类型</span></span><br><span class="line"><span class="comment">//数组转List集合(这样构建的list是定长的)</span></span><br><span class="line">Arrays.asList(Integer[] arr) </span><br><span class="line">Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br></pre></td></tr></table></figure><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102203472.png" alt="image-20220509231640934"></p></li></ul><h4 id="13-1-1-1-ArrayList"><a href="#13-1-1-1-ArrayList" class="headerlink" title="13.1.1.1 ArrayList"></a>13.1.1.1 ArrayList</h4><ul><li><p>线程不安全，效率高</p></li><li><p>扩容机制</p><p>ArraysList底层是数组实现的。jdk7 new ArrayList()底层创建了长度是10的数组，jdk8初始化长度为0，首次add时才创建了长度为10的数组。容量不够时都是扩容为原来的1.5倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定初始数组的容量,避免频繁扩容</span></span><br><span class="line">ArrayList <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="type">int</span> capacity);</span><br></pre></td></tr></table></figure></li><li><p>可以使用Collections工具类转变为线程安全的</p></li></ul><h4 id="13-1-1-2-LinkList"><a href="#13-1-1-2-LinkList" class="headerlink" title="13.1.1.2 LinkList"></a>13.1.1.2 LinkList</h4><ul><li><p>底层使用双向链表进行存储</p></li><li><p>实现了Queue接口</p></li></ul><h4 id="13-1-1-3-Vector"><a href="#13-1-1-3-Vector" class="headerlink" title="13.1.1.3 Vector"></a>13.1.1.3 Vector</h4><ul><li><p>线程安全</p></li><li><p>Vector();底层创建长度为10的数组，默认扩容为原来数组长度的两倍</p></li><li><p>一般用ArrayList代替了</p></li></ul><h3 id="13-1-2-Set"><a href="#13-1-2-Set" class="headerlink" title="13.1.2 Set"></a>13.1.2 Set</h3><ul><li><p>重写equals()和hashCode()</p></li><li><p>无序性体现在底层是按hash值存储，所以无序</p></li><li><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102214320.png" alt="image-20220510174229930"></p></li><li><p><strong>要重写hashCode用它自动生成那个就行，就保证了一致性</strong></p></li><li><p>操作就是Collection的操作</p></li></ul><h4 id="13-1-2-1-HashSet"><a href="#13-1-2-1-HashSet" class="headerlink" title="13.1.2.1 HashSet"></a>13.1.2.1 HashSet</h4><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102222614.png" alt="image-20220510155208802"></p><h4 id="13-1-2-2-LinkHashSet"><a href="#13-1-2-2-LinkHashSet" class="headerlink" title="13.1.2.2 LinkHashSet"></a>13.1.2.2 LinkHashSet</h4><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102222245.png" alt="image-20220510173557166"></p><h4 id="13-1-2-3-TreeSet"><a href="#13-1-2-3-TreeSet" class="headerlink" title="13.1.2.3 TreeSet"></a>13.1.2.3 TreeSet</h4><p>重写比较器</p><p>会把添加的元素按大小排列</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102225326.png" alt="image-20220510161332261"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(com);<span class="comment">//TreeSet传入我们定制的比较器com</span></span><br></pre></td></tr></table></figure><h3 id="13-1-3-Queue"><a href="#13-1-3-Queue" class="headerlink" title="13.1.3 Queue"></a>13.1.3 <strong>Queue</strong></h3><h4 id="13-1-3-1Queue"><a href="#13-1-3-1Queue" class="headerlink" title="13.1.3.1Queue"></a>13.1.3.1Queue</h4><p>只能在队头进行操作，队尾进队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>可以存入null元素</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102308298.png" alt="image-20220602221916572"></p><h4 id="13-1-3-2-Deque"><a href="#13-1-3-2-Deque" class="headerlink" title="13.1.3.2 Deque"></a>13.1.3.2 Deque</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; q3 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>双端队列，在两头进行操作，尽量不要添加null元素</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102308517.png" alt="image-20220602224417454"></p><p>可以当作堆栈来使用，不用stack了</p><h4 id="13-1-3-2-PriorityQueue"><a href="#13-1-3-2-PriorityQueue" class="headerlink" title="13.1.3.2 PriorityQueue"></a>13.1.3.2 PriorityQueue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; q2 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator);</span><br></pre></td></tr></table></figure><p>优先级队列种的元素根据自然顺序进行排序，或者通过在队列构建时提供的Comparator进行排序，当然这取决于使用哪种构造函数。优先级队列不允许空（null）元素</p><p>PriorityQueue是一个无界优先级队列是基于优先级堆的</p><p>优先级队列的队头元素是最小的元素，如果有多个元素并列最小，那么队头是它们其中之一</p><h4 id="13-1-3-3-BlockingQueue"><a href="#13-1-3-3-BlockingQueue" class="headerlink" title="13.1.3.3 BlockingQueue"></a>13.1.3.3 BlockingQueue</h4><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：</p><ol><li>在队列为空时，获取元素的线程会等待队列变为非空。</li><li>当队列满时，存储元素的线程会等待队列可用。</li></ol><h2 id="13-2-Map"><a href="#13-2-Map" class="headerlink" title="13.2 Map"></a>13.2 Map</h2><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102308988.png" alt="Map"></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102308956.png" alt="image-20220511150125858"></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102308670.png" alt="image-20220511175439181"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回的泛型是一个map的Entry，这个Entry也是泛型</span></span><br><span class="line">Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">sout: [<span class="number">1</span>=a, <span class="number">2</span>=b, <span class="number">3</span>=c, <span class="number">4</span>=d]</span><br></pre></td></tr></table></figure><h3 id="13-2-1-HashMap"><a href="#13-2-1-HashMap" class="headerlink" title="13.2.1 HashMap"></a>13.2.1 HashMap</h3><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102308369.png" alt="image-20220511172409047"></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307121643788.png" alt="image-20220511172438407"></p><ul><li>linkhashmap</li></ul><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102308482.png" alt="image-20220511175048624"></p><p>HashMap和双向链表合二为一即是LinkedHashMap。所谓LinkedHashMap，其落脚点在HashMap，因此更准确地说，它是一个将所有Entry节点链入一个双向链表的HashMap。由于LinkedHashMap是HashMap的子类，所以LinkedHashMap自然会拥有HashMap的所有特性。比如，LinkedHashMap的元素存取过程基本与HashMap基本类似，只是在细节实现上稍有不同。当然，这是由LinkedHashMap本身的特性所决定的，因为它额外维护了一个双向链表用于保持迭代顺序。此外，LinkedHashMap可以很好的支持LRU算法。</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102308783.png" alt="image-20230329212332504"></p><h3 id="13-2-2-TreeMap"><a href="#13-2-2-TreeMap" class="headerlink" title="13.2.2 TreeMap"></a>13.2.2 TreeMap</h3><ul><li>按照key进行排序，所以key必须是同一类型的对象</li></ul><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102309310.png" alt="image-20220511180011005"></p><ul><li><pre><code class="Java">//返回大于等于指定key的key或EntryInteger key = map.ceilingKey(2);Map.Entry&lt;Integer, String&gt; entry = map.ceilingEntry(2);//返回小于等于指定key的key或EntryInteger key1 = map.floorKey(5);Map.Entry&lt;Integer, String&gt; entry1 = map.floorEntry(5);//返回逆序的set或mapNavigableSet&lt;Integer&gt; set = map.descendingKeySet();NavigableMap&lt;Integer, String&gt; map1 = map.descendingMap();//返回集合中含有最小的Key的元素或Entry,最大是lastInteger key2 = map.firstKey();Map.Entry&lt;Integer, String&gt; entry2 = map.firstEntry();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 13.2.3 HashTable</span><br><span class="line"></span><br><span class="line">和HashMap差不多，一般不用。线程安全，效率低</span><br><span class="line"></span><br><span class="line">properties：常用来处理配置文件</span><br><span class="line"></span><br><span class="line">![image-20220812144917531](https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102309084.png)配置文件</span><br><span class="line"></span><br><span class="line">![image-20220812145013415](https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102309843.png)</span><br><span class="line"></span><br><span class="line">~~~Java</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Properties properties = new Properties();</span><br><span class="line">    FileInputStream fileInputStream = new FileInputStream(&quot;./src/properties.properties&quot;);</span><br><span class="line">    properties.load(fileInputStream);</span><br><span class="line">    String user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">    String mm = properties.getProperty(&quot;密码&quot;);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    System.out.println(mm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h2 id="13-3-Collections工具类"><a href="#13-3-Collections工具类" class="headerlink" title="13.3 Collections工具类"></a>13.3 Collections工具类</h2><p>用来操作List Set Map</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307102309177.png" alt="image-20220511182636921"></p><h2 id="13-4-相互转换"><a href="#13-4-相互转换" class="headerlink" title="13.4 相互转换"></a>13.4 相互转换</h2><ol><li><p>数组转集合</p><ul><li>遍历数组，将元素保存到集合中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n:arr)&#123;</span><br><span class="line">    list.add(n);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><ul><li><p>使用asList()方法</p><p><strong>注意</strong>：1）如果传入的参数是一个数组，那么这个数组一定要是引用类型才能将其转换为List集合，当传入基本数据类型数组时则会将这个数组对象当成一个引用类型对象存进List集合。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(arr);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>​<strong>注意</strong>：2）使用这种转换的方法，直接添加元素会报错，需要重新new一个list</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(arr);</span><br><span class="line"><span class="comment">//使用这种转换的方法，直接添加元素会报错，需要重新new一个list</span></span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">list1.add(<span class="number">4</span>);</span><br><span class="line">list1.forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>采用流的方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.stream(arr).boxed().collect(Collectors.toList());</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></li><li><p>集合转数组</p><ul><li>传入一个类型和大小完全相同的数组进行转换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">10</span>);</span><br><span class="line">list.add(<span class="number">20</span>);</span><br><span class="line">list.add(<span class="number">30</span>);</span><br><span class="line">Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[list.size()];</span><br><span class="line">list.toArray(arr);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:arr)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="14-泛型"><a href="#14-泛型" class="headerlink" title="14. 泛型"></a>14. 泛型</h1><p><a href="https://blog.csdn.net/weixin_45395059/article/details/126006369">https://blog.csdn.net/weixin_45395059/article/details/126006369</a></p><ol><li><p>静态方法不能用泛型</p></li><li><p>异常类不能用泛型</p></li><li><pre><code class="java">//T[] arr = new T[10];编译是不通过的T[] arr =(T[]) new Object[10];<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">![image-20220513152638559](https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307111249521.png)</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">Collection&lt;String&gt; list = new ArrayList&lt;String&gt;();//java8后面的&lt;String可以省略&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ol><h2 id="14-1-自定义泛型结构"><a href="#14-1-自定义泛型结构" class="headerlink" title="14.1 自定义泛型结构"></a>14.1 自定义泛型结构</h2><ul><li>泛型类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt;&#123;</span><br><span class="line">    T parameter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(T parameter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parameter = parameter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承时指明泛型类型，B就不再是一个泛型类了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(Integer parameter)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(parameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承时保留泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">A</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">(T parameter)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(parameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>&lt;T,E&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">D</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保留部分泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ED</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">D</span>&lt;Integer,E&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>泛型方法</p><p>不仅类可以声明泛型，类中的方法也可以声明仅用于自身的泛型，这种方法叫做泛型方法</p><p>泛型方法可以声明为静态的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="comment">//B后面的&lt;T&gt;可加可不加</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//泛型方法()只需要将泛型列表放置在返回类型与访问修饰符之间即可</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">(T t)</span>&#123;  <span class="comment">//类中其它方法不能使用当前方法声明的泛型，即该(T t)只作用于该泛型方法</span></span><br><span class="line">        System.out.println(t);</span><br><span class="line">        <span class="comment">//return t;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//泛型方法重载</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T, T1&gt; T <span class="title function_">printInfo</span><span class="params">(T t, T1 t1)</span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        System.out.println(t1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A&lt;String&gt; a = <span class="keyword">new</span> <span class="title class_">A</span>&lt;String&gt;();</span><br><span class="line">        a.printInfo(<span class="string">&quot;kobe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.printInfo(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        b.printInfo(<span class="string">&quot;zhangkun&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(b.printInfo(<span class="string">&quot;zhangkun&quot;</span>, <span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-2-通配符"><a href="#14-2-通配符" class="headerlink" title="14.2 通配符"></a>14.2 通配符</h2><p>？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Object[] arr1 = <span class="literal">null</span>;</span><br><span class="line">    String[] arr2 = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;shja&quot;</span>,<span class="string">&quot;sh&quot;</span>&#125;;</span><br><span class="line">    arr1 = arr2;<span class="comment">//String是Object的子类，可以赋值，是多态</span></span><br><span class="line">    System.out.println(arr1[<span class="number">0</span>]);</span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//list1 = list2;他们是并列的关系，不能直接赋值</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FanXin</span>().print(list1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用通配符的方式，这样就可以传入多种类型的List了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;?&gt; list)</span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有限制条件的通配符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">P</span>&gt;<span class="comment">//?是P类及其子类   上界通配符</span></span><br><span class="line">&lt;? <span class="built_in">super</span> P&gt;<span class="comment">//?是P类及其父类  下界通配符</span></span><br></pre></td></tr></table></figure><h1 id="15-网络编程"><a href="#15-网络编程" class="headerlink" title="15.网络编程"></a>15.网络编程</h1><h2 id="1-IP地址"><a href="#1-IP地址" class="headerlink" title="1. IP地址"></a>1. IP地址</h2><ul><li>本地回环地址</li></ul><p>“<em>本地回环地址127.0.0.1</em>，通常被称为本地回环地址(Loopback Address)，不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口。”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取本地IP地址对象</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过域名或者IP获取一个Ip地址的对象</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span>InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="2-端口号"><a href="#2-端口号" class="headerlink" title="2. 端口号"></a>2. 端口号</h2><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307122335350.png" alt="image-20220802154235231"></p><h2 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3. TCP"></a>3. TCP</h2><p>TCP或UDP的网络编程都叫socket编程</p><ul><li><p>客户端向服务器端发送文件</p><p>流程</p><blockquote><p>1.打开服务器端，会阻塞在read方法里（read()和readLine()都会读取对端发送过来的数据，如果无数据可读，就会阻塞直到有数据可读。或者到达流的末尾，这个时候分别返回-1和null。）</p><p>2.打开客户端，把文件写道socket里去，写完往下执行流会关闭</p><p>3.那么服务端的read操作也会完成</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.创建socket对象,指明服务器段的IP和端口号</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8899</span>);</span><br><span class="line">    <span class="comment">//2.获取一个输出流(只有字节的)，用于输出数据(把数据写到服务器上)</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    <span class="comment">//3.具体写数据的操作</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./src/text/hello1.txt&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = inputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//把数据写道os流里面去</span></span><br><span class="line">        os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关4.闭流资源</span></span><br><span class="line">    os.close();</span><br><span class="line">    inputStream.close();</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.创建服务器端的serverSocket，指明自己的端口号（当运行起来时，自己在哪个服务器运行IP就是多少，不需指明）</span></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line">    <span class="comment">//2.调用accept接收来自客户端的socket</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">    <span class="comment">//3.获取输入流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="comment">//4.读取输入流中的数据</span></span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//读到的数据写道baos这个流里面，方便打印输出</span></span><br><span class="line">        baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(baos.toString());</span><br><span class="line">    <span class="comment">//5.资源的关闭</span></span><br><span class="line">    baos.close();</span><br><span class="line">    is.close();</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>客户端服务端进行交互</p><blockquote><p>1.打开服务端，一直read等待数据</p><p>2.写数据，写完关闭 socket.shutdownOutput();对面read就会停止</p><p>3.此时客户端阻塞在read，服务端就行写数据，写完向下执行流关闭</p><p>4.客户端read就会停止，向下执行，关闭流</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.创建socket对象,指明服务器段的IP和端口号</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8899</span>);</span><br><span class="line">    <span class="comment">//2.获取一个输出流(只有字节的)，用于输出数据(把数据写道服务器上)</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    <span class="comment">//3.具体写数据的操作</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./src/text/hello1.txt&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = inputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//把数据写道os流里面去</span></span><br><span class="line">        os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收服务端的数据</span></span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="keyword">while</span> ((len = socket.getInputStream().read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关4.闭流资源</span></span><br><span class="line">    os.close();</span><br><span class="line">    inputStream.close();</span><br><span class="line">    socket.close();</span><br><span class="line">    baos.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.创建服务器端的serverSocket，指明自己的端口号（当运行起来时，自己在哪个服务器运行IP就是多少，不需指明）</span></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line">    <span class="comment">//2.调用accept接收来自客户端的socket</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">    <span class="comment">//3.获取输入流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="comment">//4.读取输入流中的数据</span></span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//读到的数据写道baos这个流里面</span></span><br><span class="line">        baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向客户端发送数据</span></span><br><span class="line">    socket.getOutputStream().write(<span class="string">&quot;data received&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.资源的关闭</span></span><br><span class="line">    baos.close();</span><br><span class="line">    is.close();</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-UDP"><a href="#4-UDP" class="headerlink" title="4. UDP"></a>4. UDP</h2><p>代码略，这里稍微理解就行。</p><p>package（数据包(报)）的形式发送，不用建立连接，不确保接收，速度更快。</p><h2 id="5-URL编程"><a href="#5-URL编程" class="headerlink" title="5. URL编程"></a>5. URL编程</h2><p>统一资源定位符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;url&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="16-反射"><a href="#16-反射" class="headerlink" title="16. 反射"></a>16. 反射</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息，并能操作任何对象的内部属性及方法</p><p>反射被视为动态语言的关键</p><h2 id="2-Class"><a href="#2-Class" class="headerlink" title="2. Class"></a>2. Class</h2><p>获取Class实例的方法（获取运行时类）</p><ul><li><pre><code class="Java">Class&lt;Person&gt; clazz = Person.class;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ~~~Java</span><br><span class="line">  Person person = new Person();</span><br><span class="line">  Class&lt;? extends Person&gt; aClass = person.getClass();</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="Java">//注意要写全类名Class&lt;?&gt; aClass1 = Class.forName(&quot;com.atzrh.java.Person&quot;);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ~~~Java</span><br><span class="line">  ClassLoader classLoader = 类名.class.getClassLoader();</span><br><span class="line">  Class&lt;?&gt; aClass2 = classLoader.loadClass(&quot;com.atzrh.java.Person&quot;);</span><br></pre></td></tr></table></figure>clazz == aClass == aClass1 == aClass2</code></pre></li></ul><p>哪些类型可以有class对象：</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307122338505.png" alt="image-20220812133126280"></p><h2 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3. 类加载器"></a>3. 类加载器</h2><p>Class Loader</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307122338372.png" alt="image-20220812141122382"></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307122339228.png" alt="image-20220812141351036"></p><p>加载配置文件时通过类加载器获取输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> PropertiesTest.class.getClassLoader();</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;properties.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">    properties.load(inputStream);</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">mm</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;密码&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    System.out.println(mm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-创建运行时类对象"><a href="#4-创建运行时类对象" class="headerlink" title="4. 创建运行时类对象"></a>4. 创建运行时类对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Class实例</span></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.atzrh.java.Person&quot;</span>);</span><br><span class="line"><span class="comment">//运行时类要求提供一个空参构造器，并且访问权限得够，通常设置为public</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) aClass.newInstance();</span><br><span class="line"><span class="comment">//反射的动态性：程序执行时才知道具体构造的是哪个对象</span></span><br></pre></td></tr></table></figure><h2 id="5-获取运行时类内部结构"><a href="#5-获取运行时类内部结构" class="headerlink" title="5. 获取运行时类内部结构"></a>5. 获取运行时类内部结构</h2><ol><li>获取类的属性，以及属性的权限修饰符、类型、变量名</li><li>获取类的方法，以及方法的权限修饰符、注解、返回值类型、方法名（参数信息）、异常</li><li>获取运行时类的构造器</li><li>获取运行时类的父类</li><li>获取运行时类实现的接口、所在包、注解</li></ol><h2 id="6-调用运行时类的结构"><a href="#6-调用运行时类的结构" class="headerlink" title="6. 调用运行时类的结构"></a>6. 调用运行时类的结构</h2><ol><li><p>调用指定的属性并可以设定值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取运行时类</span></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.atzrh.java.Person&quot;</span>);</span><br><span class="line"><span class="comment">//创建运行时类对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) aClass.newInstance();</span><br><span class="line"><span class="comment">//获取指定的属性</span></span><br><span class="line"><span class="type">Filed</span> <span class="variable">name</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//保证当前属性可访问，才能有如下操作</span></span><br><span class="line">name.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//Set方法</span></span><br><span class="line">name.set(person,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"><span class="comment">//Get方法</span></span><br><span class="line">name.get(person);</span><br></pre></td></tr></table></figure></li><li><p>调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取运行时类</span></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.atzrh.java.Person&quot;</span>);</span><br><span class="line"><span class="comment">//创建运行时类对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) aClass.newInstance();</span><br><span class="line"><span class="comment">//通过方法名和形参列表获取某个指定方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> aClass.getDeclaredMethod(<span class="string">&quot;show&quot;</span>,String.class);</span><br><span class="line"><span class="comment">//保证方法可访问</span></span><br><span class="line">show.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//传入通过对象和参数调用方法，没有返回值返回null</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> show.invoke(person,<span class="string">&quot;CHN&quot;</span>);</span><br><span class="line"><span class="comment">//静态方法调用不用传对象</span></span><br></pre></td></tr></table></figure></li><li><p>调用指定构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取对应参数列表的构造器</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//创建运行时类对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">&quot;Tom&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="7-反射应用：动态代理"><a href="#7-反射应用：动态代理" class="headerlink" title="7. 反射应用：动态代理"></a>7. 反射应用：动态代理</h2><p><strong>代理模式和接口是密不可分的</strong></p><p>代理设计模式：使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理</p><p>前面第7章的代理是静态代理，代理类和目标对象在编译期间就确定了下来</p><p>动态代理举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//被代理类对象</span></span><br><span class="line">        <span class="type">SuperMan</span> <span class="variable">superMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperMan</span>();</span><br><span class="line">        <span class="comment">//代理类的对象</span></span><br><span class="line">        <span class="type">Human</span> <span class="variable">instance</span> <span class="operator">=</span> (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">//通过代理类对象，调用被代理类的同盟==同名方法</span></span><br><span class="line">        instance.eat(<span class="string">&quot;hotpot&quot;</span>);</span><br><span class="line">        System.out.println(instance.getBelief());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态代理的那个Nike工厂也可用动态代理</span></span><br><span class="line">        <span class="type">NikeClothFactory</span> <span class="variable">nikeClothFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NikeClothFactory</span>();</span><br><span class="line">        <span class="type">ClothFactory</span> <span class="variable">o</span> <span class="operator">=</span>(ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);</span><br><span class="line">        o.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//要实现的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">    String <span class="title function_">getBelief</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMan</span> <span class="keyword">implements</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBelief</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产代理类的一个工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyFactory</span>&#123;</span><br><span class="line">    <span class="comment">//得到一个代理类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object object)</span>&#123;</span><br><span class="line">        <span class="comment">//object是被代理类的对象,根据这个动态的造一个代理类对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="comment">//通过代理类的对象调用方法a时，会自动调用如下的方法：invoke..</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                <span class="comment">//被代理类要执行的方法就声明在invoke中</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(object, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="17-IO"><a href="#17-IO" class="headerlink" title="17. IO"></a>17. IO</h1><h2 id="1-Scanner"><a href="#1-Scanner" class="headerlink" title="1. Scanner"></a>1. Scanner</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//创建一个Scanner对象用于接收</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scan.next();<span class="comment">//接收String</span></span><br><span class="line">scan.nextInt();</span><br><span class="line">scan.nextFloat();</span><br><span class="line">scan.nextBoolean();</span><br><span class="line"><span class="comment">//Scanner没有获取char型的方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">genderStr</span> <span class="operator">=</span> scan.next();</span><br><span class="line"><span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> genderStr.charAt(<span class="number">0</span>);<span class="comment">//获取字符串的索引变为</span></span><br></pre></td></tr></table></figure><h2 id="2-格式化输出"><a href="#2-格式化输出" class="headerlink" title="2. 格式化输出"></a>2. 格式化输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="type">double</span> pi=<span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> i=<span class="number">100</span>;</span><br><span class="line"><span class="comment">//&quot;%&quot;表示进行格式化输出，其后是格式的定义</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%f\n&quot;</span>,pi);<span class="comment">//&quot;f&quot;表示格式化输出浮点数</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%d\n&quot;</span>,i);<span class="comment">//&quot;d&quot;表示格式化输出十进制整数</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%o\n&quot;</span>,i);<span class="comment">//&quot;o&quot;表示格式化输出八进制整数</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%x\n&quot;</span>,i);<span class="comment">//&quot;x&quot;表示格式化输出十六进制整数</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%s\n&quot;</span>,str);<span class="comment">//&quot;s&quot;表示格式化输出字符串</span></span><br><span class="line">System.out.printf(<span class="string">&quot;一个字符串：%s，一个浮点数：%f，一个整数：%d&quot;</span>,str,pi,i);<span class="comment">//可以一次输出多个变量，注意顺序即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toBinaryString(i)</span><br></pre></td></tr></table></figure><h2 id="3-File类"><a href="#3-File类" class="headerlink" title="3. File类"></a>3. File类</h2><ol><li>Test单元测试里当前目录指的是当前Module下的目录</li><li>main方法里当前目录指的是当前工程</li></ol><ul><li>File类对象构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//根据传入的参数得到一个文件或者文件目录</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//得到在file1（也可以传字符串）目录下的 的文件或目录xx</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file1, <span class="string">&quot;xx&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以下全是File类对象的方法</li></ul><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131443328.png" alt="image-20220514161429836"></p><ol><li><p>先获得一个File对象，然后去创建它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">    file.createNewFile();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    file.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131456161.png" alt="image-20220514165209302"></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">delete</span><span class="params">()</span>;<span class="comment">//删除文件或者空的文件目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归的去删除一个非空的文件目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteFile</span><span class="params">(File file)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">        file.delete();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        file.delete();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;files.length ; i++) &#123;</span><br><span class="line">            deleteFile(files[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    file.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-IO流"><a href="#4-IO流" class="headerlink" title="4. IO流"></a>4. IO流</h2><h3 id="1-IO"><a href="#1-IO" class="headerlink" title="1.IO"></a>1.IO</h3><ul><li>字节流 字符流</li></ul><p>​  输入流 输出流（都是相对于内存来说的，读：把文件读到内存  写：从内存写到文件）</p><p>Reader：读文件    Writer：写文件</p><p>Input：读文件      Output：写文件</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131457659.png" alt="image-20220722180101240"></p><p>​节点（文件）流  处理流</p><ul><li>（下图 上面是抽象基类，访问文件这一行属于节点流，可直接作用于文件，下面的都属于处理流，要作用于节点流才能处理文件)</li></ul><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131458073.png" alt="image-20220515152311767"></p><ol><li><p><strong>FileReader&amp;&amp;FileWriter</strong></p><ul><li><p>读数据完整流程</p><p>读数据（读到内存），文件要存在，不然会报错</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把fr定义在&#123;&#125;里的话，下面finally&#123;&#125;就没有了</span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//1.实例化File类对象，指明要操作的文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./IO/hello.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//2.提供具体的流</span></span><br><span class="line">    fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file1);</span><br><span class="line">    <span class="comment">//3.读入数据,read()返回的是每次读入字符的字符码，文件末尾就是-1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fr.read();</span><br><span class="line">    <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println((<span class="type">char</span>) data);</span><br><span class="line">        data = fr.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        <span class="keyword">if</span> (fr!=<span class="literal">null</span>) &#123;</span><br><span class="line">            fr.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>read(char[])，每次可读入多个</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个5的char型数组，相当于每次可最多读取5个字符</span></span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="comment">//read返回的是每次读入字符的数量(最后一次可能不为5),读完返-1</span></span><br><span class="line"><span class="keyword">while</span>((len = fr.read(cbuf)!=-<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//因为可能数组存不满，所以要用len，不能用cbuf.length</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        System.out.print(cbuf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>写数据完整流程</p><p>写到文件，File指向的文件不存在则会创建</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//1. 提供file类的对象，指明写出到的文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./IO/hello1.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 提供FileWriter的对象，用于数据的写出（可指定方式：覆盖or追加）</span></span><br><span class="line">    fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file1,<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//3. 写出数据(若file1对应文件不存在则自动创建)</span></span><br><span class="line">    fw.write(<span class="string">&quot;\nhello1&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//4. 关闭资源流</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fw != <span class="literal">null</span>) &#123;</span><br><span class="line">            fw.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使代码逻辑清晰，以下代码均throws异常（实际开发中应该如上）</p><ul><li>使用输入输出流进行文件复制操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 构造File类对象，指明要操作的文件</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./src/text/hello1.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./src/text/hello2.txt&quot;</span>);</span><br><span class="line"><span class="comment">//2. 创建输入输出流</span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file1);</span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file2);</span><br><span class="line"><span class="comment">//3. 文件读取，写入</span></span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span> ((len = fr.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//每次写入cbuf的0-len长度的字符</span></span><br><span class="line">    fw.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.流资源关闭</span></span><br><span class="line">fr.close();</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure></li><li><p><strong>FileInputStream&amp;&amp;FileOutputStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作基本都一样</span></span><br><span class="line"><span class="comment">//2. 创建输入输出流,使用字节流</span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line"><span class="comment">//3. 文件读取的时候使用字节数组</span></span><br><span class="line"><span class="type">byte</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>当使用字节流去处理文字时，使用字节数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>而在UTF-8里，英文数字都是一个byte存储，汉字是3个byte</p><p>而你是每5个byte的去读，当你每读5个就通过控制台输出的话，汉字的3个byte可能就不在每批的那5个里，所以极可能乱码</p><ul><li><p>字符流处理：文本文件（.txt .java .c .cpp）</p><p>字节流处理：非文本文件（.jpg .doc…….）</p></li></ul></li><li><p><strong>缓冲流</strong></p><p>处理流的一种，要作用于节点流</p><p>实际工程中，通常使用缓冲流，因为它的速度更快</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 构造File类对象，指明要操作的文件</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./src/text/hello1.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./src/text/hello2.txt&quot;</span>);</span><br><span class="line"><span class="comment">//2.1. 创建输入输出流（字节流）</span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file1);</span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file2);</span><br><span class="line"><span class="comment">//2.2. 创建缓冲流（对应的字节缓冲流）</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line"><span class="comment">//3. 文件传输的细节</span></span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span> ((len = bufferedReader.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//每次写入cbuf的0-len长度的字符</span></span><br><span class="line">    <span class="comment">//在缓冲流的输出流中，有一个缓冲。输出达到缓冲区域上限时，就会输出出去(bufferedWriter.flush()可主动刷新缓冲)</span></span><br><span class="line">    bufferedWriter.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.流资源关闭，外层处理流关闭内层节点流会自动关闭    </span></span><br><span class="line">bufferedReader.close();</span><br><span class="line">bufferedWriter.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以不造File对象，直接把文件路径传入节点流</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;./src/text/hello1.txt&quot;</span>));</span><br><span class="line"><span class="comment">//缓冲流每次可以读一行</span></span><br><span class="line">String data;</span><br><span class="line"><span class="keyword">while</span> ((data=bufferedReader.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.println(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>转换流</strong></p><p>实现字节流—-&gt;字符流</p><ul><li><p>InputStreamReader</p><p>字节的读流—&gt;字符的读流</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.字节输入（读）流</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./text/hello1.txt&quot;</span>);</span><br><span class="line"><span class="comment">//2. 转换为字符输入（读）流</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fileInputStream, StandardCharsets.UTF_8);</span><br><span class="line"><span class="comment">//3.按照字符流的方式读数据</span></span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span> ((len=inputStreamReader.read(cbuf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>OutputStreamWriter</p><p>字节的写流—&gt;字符的写流</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用来更改编码格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.字节输入输出流</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./src/text/hello1.txt&quot;</span>);</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./src/text/hello2.txt&quot;</span>);</span><br><span class="line"><span class="comment">//2. 转换为字符输入输出流</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fileInputStream, StandardCharsets.UTF_8);</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fileOutputStream, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"><span class="comment">//3.按照字符流的方式读写数据</span></span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span> ((len=inputStreamReader.read(cbuf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    outputStreamWriter.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">inputStreamReader.close();</span><br><span class="line">outputStreamWriter.close();</span><br></pre></td></tr></table></figure></li><li><p><strong>标准输入输出流</strong></p><p>标准：键盘输入，控制台输出</p><p>可调用System类的输入输出方法修改输入输出位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.in<span class="comment">//返回的是一个字节输入流（从键盘读入）</span></span><br><span class="line">System.out<span class="comment">//返回的是一个字节输出流（写出到控制台）</span></span><br></pre></td></tr></table></figure></li><li><p>打印流</p><p>两个都是输出流</p><p>PrintStream</p><p>PrintWriter</p></li><li><p>数据流</p><p>方便保存Java的基本数据类型和String</p><ul><li>DataOutputStream</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./src/text/hello1.txt&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().toString();</span><br><span class="line"><span class="comment">//写入String用writeUTF</span></span><br><span class="line">dataOutputStream.writeUTF(time);</span><br><span class="line">dataOutputStream.flush();<span class="comment">//刷新，立马写入文件（默认达到缓冲区上限才写，其它流同理）</span></span><br><span class="line">dataOutputStream.close();</span><br></pre></td></tr></table></figure><ul><li>DataInputStream</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./src/text/hello1.txt&quot;</span>));</span><br><span class="line"><span class="comment">//如果写入多个数据，读的时候顺序要和写入顺序一样</span></span><br><span class="line">System.out.println(dataInputStream.readUTF());</span><br><span class="line">dataInputStream.close();</span><br></pre></td></tr></table></figure></li><li><p>对象流</p><p>ObjectInputStream  ：读取  反序列化</p><p>ObjectOutputStream：保存  序列化</p><p>弥补7，除了基本数据类型还可以操作对象</p><ul><li>自定义类Person满足以下要求才能序列化</li></ul><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131515613.png" alt="image-20220728224840468"></p><p>关于上图补充：被以上两个关键字修饰的成员变量，其实可以序列化，但是值保存不了，即反序列化的时候读取的是默认值（String为null，int为0等等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标识接口，没有任何需要实现的抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>RandomAccessFile</p><p>不同于上述都是继承于4个抽象基类，他直接继承于Object类，同时实现了DataInput和DataOutput接口。它根据构造器的参数去指定这个流是实现输入还是输出的功能</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131515804.png" alt="image-20220728231254953"></p><p>代码逻辑一样：</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131516401.png" alt="image-20220728231724879"></p><p>作为输出流（写文件）时：</p><p>通过seek()调整写入时的指针位置</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131516619.png" alt="image-20220728232930069"></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131516019.png" alt="image-20220728234646400"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BreakPTrans</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">copy</span><span class="params">(String src, String des)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">copySuccess</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">seekFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./BreakPointDL/src/file/seek.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">FileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">FileWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//记录每次读的位置</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">seek</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果记录seek的文件存在，则要更新seek</span></span><br><span class="line">            <span class="keyword">if</span> (seekFile.exists()) &#123;</span><br><span class="line">                FileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(seekFile);</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="type">int</span> data;</span><br><span class="line">                <span class="keyword">while</span> ((data = FileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    stringBuilder.append((<span class="type">char</span>) data);</span><br><span class="line">                &#125;</span><br><span class="line">                seek = Long.parseLong(<span class="keyword">new</span> <span class="title class_">String</span>(stringBuilder));</span><br><span class="line">            &#125;</span><br><span class="line">            FileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(seekFile);</span><br><span class="line">            r = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(src, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">            r.seek(seek);</span><br><span class="line">            w = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(des, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">            <span class="comment">//指针指向末尾，实现追加操作</span></span><br><span class="line">            w.seek(w.length());</span><br><span class="line">            <span class="type">int</span> data;</span><br><span class="line">            <span class="keyword">while</span> ((data = r.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                w.write((<span class="type">char</span>) data);</span><br><span class="line">                System.out.println(<span class="string">&quot;one byte has been written&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            copySuccess = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (FileWriter != <span class="literal">null</span> &amp;&amp; r != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//把退出时指针位置记录到文件</span></span><br><span class="line">                    FileWriter.write(String.valueOf(r.getFilePointer()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">                    r.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (w != <span class="literal">null</span>) &#123;</span><br><span class="line">                    w.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (FileReader != <span class="literal">null</span>) &#123;</span><br><span class="line">                    FileReader.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (FileWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">                    FileWriter.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copySuccess;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-NIO"><a href="#2-NIO" class="headerlink" title="2.NIO"></a>2.NIO</h3><p>pass</p><h1 id="18-时间"><a href="#18-时间" class="headerlink" title="18. 时间"></a>18. 时间</h1><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> Math.random();<span class="comment">//随机生成一个[0.0,1.0)的随机数，double类型</span></span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="19-2-1-System类"><a href="#19-2-1-System类" class="headerlink" title="19.2.1 System类"></a>19.2.1 System类</h3><ul><li>此方法适合于计算时间差</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前时间（距离时间戳1970年..）的毫秒数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis()</span><br></pre></td></tr></table></figure><h3 id="19-2-2-Date类"><a href="#19-2-2-Date类" class="headerlink" title="19.2.2 Date类"></a>19.2.2 Date类</h3><ul><li>Java.util.Date</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//创建对应当前时间的Date对象</span></span><br><span class="line">date1.toString();<span class="comment">//显示当前时区的年月日时分秒</span></span><br><span class="line">date1.getTime();<span class="comment">//显示时间戳（获取当前时间（距离时间戳1970年..）的毫秒数）</span></span><br><span class="line"></span><br><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">41524512L</span>);<span class="comment">//创建自定义时间戳的Date对象</span></span><br></pre></td></tr></table></figure><ul><li><p>Java.sql.Date</p><p><strong>是Java.util.Date的子类</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">41524512L</span>);<span class="comment">//只有时间戳的这个构造方法</span></span><br></pre></td></tr></table></figure><p>可以通过获取时间戳的方式进行两种Date的转换</p><h3 id="19-2-3-SimpleDateFormat类"><a href="#19-2-3-SimpleDateFormat类" class="headerlink" title="19.2.3 SimpleDateFormat类"></a>19.2.3 SimpleDateFormat类</h3><ul><li><p><strong>java.text.SimpleDateFormat</strong></p><p>Date类的API不利于国际化，大部分已被废弃</p><p>SimpleDateFormat可以对Date类进行格式化解析</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造器pattern = &quot;22-7-12 下午5:01&quot;</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();</span><br><span class="line"><span class="comment">//可以格式化和解析这个pattern类型的字符串</span></span><br><span class="line"><span class="comment">//一般常用pattern = &quot;yyyy-MM-dd hh:mm:ss&quot;</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(pattern);</span><br></pre></td></tr></table></figure><ol><li><p>格式化：日期-&gt;字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">long</span> <span class="variable">ms</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">//可以传Date，时间戳</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> simpleDateFormat.format(ms);</span><br></pre></td></tr></table></figure></li><li><p>解析：字符串-&gt;日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;22-7-12 下午5:01&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> simpleDateFormat.parse(str);</span><br><span class="line">System.out.println(date1);</span><br></pre></td></tr></table></figure></li></ol><h3 id="19-2-4-Calendar类"><a href="#19-2-4-Calendar类" class="headerlink" title="19.2.4 Calendar类"></a>19.2.4 Calendar类</h3><p>Calendar是一个抽象基类，主用于完成日期字段之间相互操作的功能</p><ul><li><p>创建实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类，调用静态方法得到实例</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br></pre></td></tr></table></figure></li><li><p>get set 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前时间是本月的第几天</span></span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line"><span class="comment">//直接设置calendar为本月的第20天</span></span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH, <span class="number">20</span>);</span><br></pre></td></tr></table></figure></li><li><p>add方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本月第几天加3天,也可以加负数，表示减</span></span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li><li><p>和Date的相互转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getTime()</span></span><br><span class="line"><span class="comment">//Calendar-&gt;Date</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">//setTime()</span></span><br><span class="line"><span class="comment">//Date-&gt;Calendar</span></span><br><span class="line">calendar.setTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure></li></ul><h3 id="19-2-4-JDK8的时间API"><a href="#19-2-4-JDK8的时间API" class="headerlink" title="19.2.4 JDK8的时间API"></a>19.2.4 JDK8的时间API</h3><ul><li><strong>LocalDateTime</strong></li></ul><ol><li><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前时间.now()</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();<span class="comment">//2022-07-14</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now();<span class="comment">//14:15:24.020</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now();<span class="comment">//2022-07-14T14:15:24.020</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义时间.of()有多种构造器供使用</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">14</span>,<span class="number">54</span>);</span><br></pre></td></tr></table></figure></li><li><p>get操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> dateTime.getDayOfMonth();</span><br><span class="line"><span class="type">DayOfWeek</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> dateTime.getDayOfWeek();</span><br></pre></td></tr></table></figure></li><li><p>with操作，设置日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dateTime2</span> <span class="operator">=</span> dateTime.withDayOfMonth(<span class="number">25</span>);</span><br></pre></td></tr></table></figure></li><li><p>日期加减</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dateTime3</span> <span class="operator">=</span> dateTime.plusDays(<span class="number">3</span>);<span class="comment">//加</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dateTime4</span> <span class="operator">=</span> dateTime.minusDays(<span class="number">3</span>);<span class="comment">//减</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p><strong>Instant</strong></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131519224.png" alt="image-20220714154136806"></p></li><li><p>DateTimeFormatter</p></li></ul><ol><li><p>创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><pre><code class="Java">//将String转换为LocalDateTime的对象String dateTimeStr= &quot;2016-10-25 12:00:00&quot;;DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);//把Str按照formatter进行转换LocalDateTime localDateTime=LocalDateTime.parse(dateTimeStr,formatter);//将LocalDateTime的对象转换为StringString format = localDateTime.format(formatter);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 19. Java8</span><br><span class="line"></span><br><span class="line">## 1. 函数式接口</span><br><span class="line"></span><br><span class="line">### 1. Lambda</span><br><span class="line"></span><br><span class="line">本质：作为接口的实例（它是一个对象）。依赖函数式接口（该接口只能有一个抽象方法）</span><br><span class="line"></span><br><span class="line">匿名实现类的对象可以替换为Lambda表达式</span><br><span class="line"></span><br><span class="line">- -&gt;左边：Lambda形参列表（就是接口中抽象方法的形参列表）</span><br><span class="line">  1. 形参的参数类型可以省略（类型推断）</span><br><span class="line">  2. 若只有一个参数，小括号也可以省略</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- -&gt;右边：Lambda体（就是重写的抽象方法的方法体）</span><br><span class="line">  1. Lambda体应用&#123;&#125;包裹</span><br><span class="line">  2. 如果该方法只有一条执行语句，可省略&#123;&#125;,如果该条是return语句，return也可以省略</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2. Functional</span><br><span class="line"></span><br><span class="line">函数式接口（只有一个抽象方法的接口）</span><br><span class="line"></span><br><span class="line">可通过注解  @FunctionalInterface  修饰</span><br><span class="line"></span><br><span class="line">可通过Lambda表达式来创建函数式接口的对象</span><br><span class="line"></span><br><span class="line"> ![image-20220815104432429](https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131522484.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3. 方法引用</span><br><span class="line"></span><br><span class="line">Method Reference</span><br><span class="line"></span><br><span class="line">本质上就是Lambda表达式</span><br><span class="line"></span><br><span class="line">- 对象::实例方法</span><br><span class="line"></span><br><span class="line">  ~~~Java</span><br><span class="line">  Consumer&lt;String&gt; con1 = str-&gt; System.out.println(str);</span><br><span class="line">  con1.accept(&quot;北京&quot;);</span><br><span class="line">  </span><br><span class="line">  //Consumer中的void accept(T t)</span><br><span class="line">  //System.out对象中的void println(T t)</span><br><span class="line">  Consumer&lt;String&gt; con2 = System.out::println;</span><br><span class="line">  con2.accept(&quot;南京&quot;);</span><br></pre></td></tr></table></figure></code></pre></li></ol><ul><li><p>类::静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com1 = (o1,o2)-&gt;o1.compareTo(o2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Comparator中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment">//Integer中的int compare(T t1,T t2)</span></span><br><span class="line">Comparator&lt;Integer&gt; com2 = Integer::compareTo;</span><br></pre></td></tr></table></figure></li><li><p>类::实例·方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BiPredicate&lt;String,String&gt; pre1 = (s1,s2)-&gt;s1.equals(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//BiPredicate中的Boolean test(T t1,T t2)</span></span><br><span class="line"><span class="comment">//String中的Boolean t1.equals()</span></span><br><span class="line">BiPredicate&lt;String,String&gt; pre2 = String::equals;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-构造器引用"><a href="#4-构造器引用" class="headerlink" title="4. 构造器引用"></a>4. 构造器引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始写法</span></span><br><span class="line">Supplier&lt;Person&gt; p1 = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Person&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Lambda表达式</span></span><br><span class="line">Supplier&lt;Person&gt; p2 = ()-&gt;<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="comment">//构造器引用</span></span><br><span class="line">Supplier&lt;Person&gt; p3 = Person::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><h2 id="2-StreamAPI"><a href="#2-StreamAPI" class="headerlink" title="2. StreamAPI"></a>2. StreamAPI</h2><p>使用StreamAPI对集合数据进行操作，就类似于SQL进行的数据库查询</p><h3 id="1-创建Stream"><a href="#1-创建Stream" class="headerlink" title="1. 创建Stream"></a>1. 创建Stream</h3><ul><li><p>通过集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list;</span><br><span class="line"><span class="comment">//返回一个顺序流</span></span><br><span class="line">Stream&lt;Integer&gt; stream1 = list.stream();</span><br><span class="line"><span class="comment">//返回一个并行流</span></span><br><span class="line">Stream&lt;Integer&gt; stream2 = list.parallelStream();</span><br></pre></td></tr></table></figure></li><li><p>通过数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream1</span> <span class="operator">=</span> Arrays.stream(arr);</span><br><span class="line"></span><br><span class="line">Stream&lt;Person&gt; stream2 = Arrays.stream(Person数组);</span><br></pre></td></tr></table></figure></li><li><p>Stream.of()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure></li><li><p>无限流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从0开始，每次加2，截取前10个，对每个元素进行输出操作</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, t-&gt;t+<span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-中间操作"><a href="#2-中间操作" class="headerlink" title="2. 中间操作"></a>2. 中间操作</h3><p>流就和iterator一样，进行了中间操作，然后进行了结尾操作（例如：forEach(System.out::println)）。就不能再操作这个流了，它已经结束了</p><p><strong><font color="Red">经过 中间操作得到的还是一个Stream</font></strong></p><ul><li><p>筛选与切片</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//过滤流：筛选输出arr中的偶数</span></span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr);</span><br><span class="line">stream.filter(e-&gt;e%<span class="number">2</span>==<span class="number">0</span>).forEach(e-&gt; System.out.print(e+<span class="string">&quot; &quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line"><span class="comment">//截断流：只要前两个元素</span></span><br><span class="line">Arrays.stream(arr).limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line"><span class="comment">//跳过前2个元素</span></span><br><span class="line">Arrays.stream(arr).skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line"><span class="comment">//筛选：去除重复元素：依据hashcode和equals方法</span></span><br><span class="line">Arrays.stream(arr).distinct().forEach(System.out::println);</span><br><span class="line">System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bbc&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd11&quot;</span>);</span><br><span class="line"><span class="comment">//将流中的每一个元素都映射成另一个元素（大写）</span></span><br><span class="line">list.stream().map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//.flatMap</span></span><br><span class="line"><span class="comment">//如果map把每个元素映射成了一个Stream，那么list.stream().map(映射成Stream)返回</span></span><br><span class="line"><span class="comment">//的就是stream构成的stream，而.flatMap会把各个stream拆包还是返回像上面的由元素构成的stream</span></span><br></pre></td></tr></table></figure></li><li><p>排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; list = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">52</span>,<span class="string">&quot;Tom&quot;</span>), <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>,<span class="string">&quot;Jack&quot;</span>), <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">24</span>,<span class="string">&quot;Jerry&quot;</span>), <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">30</span>,<span class="string">&quot;Smith&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//按年龄进行排序</span></span><br><span class="line">list.stream().sorted((p1,p2)-&gt;-(p1.getAge()-p2.getAge())).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-终止操作"><a href="#3-终止操作" class="headerlink" title="3. 终止操作"></a>3. 终止操作</h3><ul><li><p>匹配与查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查是否匹配所有元素</span></span><br><span class="line"><span class="comment">//是否所有人年龄都大于18</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">allMatch</span> <span class="operator">=</span> list.stream().allMatch(p -&gt; p.getAge() &gt; <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查是否至少匹配一个</span></span><br><span class="line"><span class="comment">//是否至少一个人年龄大于18</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> list.stream().anyMatch(p -&gt; p.getAge() &gt; <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//findFirst 返回流中第一个元素,放在Optional容器</span></span><br><span class="line">Optional&lt;Person&gt; first = list.stream().findFirst();</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> first.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">//count 流中元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//max</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//min</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//forEach 内部迭代</span></span><br></pre></td></tr></table></figure></li><li><p>规约</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射成age流，再对流中元素求和</span></span><br><span class="line">Optional&lt;Integer&gt; sum = list.stream().map(Person::getAge).reduce(Integer::sum);</span><br></pre></td></tr></table></figure></li><li><p>收集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射成为大写后收集成一个list或者set等</span></span><br><span class="line">List&lt;String&gt; list1 = list.stream().map(String::toUpperCase).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>.collect之后可以用Collectors工具类进行一系列操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>转换为集合;</span><br><span class="line">List&lt;String&gt; custListResult = list.stream().collect(Collectors.toCollection(LinkedList::<span class="keyword">new</span>));<span class="comment">//转换为特定的集合LinkList</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>转换为map;</span><br><span class="line">Map&lt;String, Integer&gt; mapResult = list.stream().collect(Collectors.toMap(Function.identity(), String::length));<span class="comment">//Function.identity()就是x-&gt;x即流中元素本身</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>连接元素;</span><br><span class="line"><span class="type">String</span> <span class="variable">joinResult</span> <span class="operator">=</span> list.stream().collect(Collectors.joining());</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Option类"><a href="#3-Option类" class="headerlink" title="3. Option类"></a>3. Option类</h2><p>避免空指针问题</p><h1 id="20-Java9以后"><a href="#20-Java9以后" class="headerlink" title="20. Java9以后"></a>20. Java9以后</h1><h2 id="1-java9"><a href="#1-java9" class="headerlink" title="1. java9"></a>1. java9</h2><ul><li><p>模块化系统</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个module.info文件来导入需要的模块</span></span><br></pre></td></tr></table></figure></li><li><p>REPL工具</p><p>像python一样在命令行就能交互式的编程环境</p><p>命令行输入jshell打开该交互工具</p></li><li><p>接口</p><p>新增可以定义私有方法</p></li><li><p>砖石操作符</p><p>在8中，使用匿名对象时，后面不能省略</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131539277.png" alt="image-20220817111653245"></p></li><li><p>try结构</p><p>java8之前，括号里不能写</p><p>java8：</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131539598.png" alt="image-20220817114018319"></p><p>java9：</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131539998.png" alt="image-20220817114158873"></p></li><li><p>String</p><p>底层时char型数组存储，每个字符两个字节</p><p>java9：底层为字节型数组存储，拉丁一个字节，汉字两个字节</p></li><li><p>集合工厂</p><p>快速创建只读集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set.of();</span><br><span class="line">List.of();</span><br></pre></td></tr></table></figure></li><li><p>流转换</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131539900.png" alt="image-20220817160832992"></p></li><li><p>StreamAPI</p><p>增强版</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131539993.png" alt="image-20220817161313019"></p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131539514.png" alt="image-20220817161611954"></p></li><li><p>optional</p><p>optional容器也可以转换为流</p></li><li><p>Nashorn引擎</p><p>可以在JVM上运行JavaScript程序</p></li></ul><h2 id="2-Java10"><a href="#2-Java10" class="headerlink" title="2. Java10"></a>2. Java10</h2><ul><li><p>局部变量类型推断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> num : list)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131540133.png" alt="image-20220817213314639"></p></li></ul><h2 id="3-java11"><a href="#3-java11" class="headerlink" title="3. java11"></a>3. java11</h2><ul><li><p>Epsilon</p></li><li><p>ZGC</p></li><li><p>字符串新方法</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131540096.png" alt="image-20220817214852547"></p></li></ul><h1 id="A-Eclipse"><a href="#A-Eclipse" class="headerlink" title="A. Eclipse"></a>A. Eclipse</h1><ul><li><p>创建一个工程：</p><ol><li>在Package Explorer里新建一个Java project</li><li>在src目录下新建一个包（包名：com.at作者名.包名）</li><li>在包里新建一个class</li></ol></li><li><p>Perspective(透视图，选择Java EE或者Java SE等)<img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131540662.png" alt="image-20220125195915662"></p><p>Quick Access（快速搜索一些工具）</p></li><li><p>window-&gt;preferences-&gt;General-&gt;workspace-&gt;默认编码改成UTF-8</p></li><li><p>写个main，alt+&#x2F; 一下会出来选择</p><p>syso + 回车   标准输出</p></li><li><p>导入Javaproject</p><ol><li><p>比如给你发了一个文件过来，你是不能直接改名的，导入到工作空间后修改才有效</p></li><li><p>file-&gt;import-&gt;<img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131540308.png" alt="image-20220125204506783"></p><p>把勾打上，就在此空间复制了一份，原来的就可以删除了，不然链接的还是原来的文件</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131540481.png" alt="image-20220125204556096"></p></li></ol></li><li><p>关联Java源文件后，按住CTRL就可以查看Java的比如String的源代码，左边outline可以看到他的结构</p></li><li><p>作者信息 package和method设置后    &#x2F;**回车        即可显示</p></li><li><p>快捷键：Ctrl+shift+&#x2F; 多行注释选中代码</p><p>​Ctrl+shift+\ 取消多行注释</p><p>​Ctrl+&#x2F;注释取消注释</p><p>​Ctrl+d 删除光标所在行代码</p><p>​alt+up&#x2F;down 移动光标所在行代码</p><p>​ctrl+alt+down 向下复制所选区域的代码</p><p>​alt+shift+s 选择generate getters and setters(生成获得和设置类属性的方法)以及重写，设置构造器等，不用手写。</p></li><li><p>代码自动补全：window-&gt;preference-&gt;java-&gt;editor-&gt;content  Assist</p><p>把Auto activation trigger for Java 后面的改为.qwer….键盘上的所有键</p></li><li><p>debug模式：</p><p>双击行左侧设置断点；</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131540700.png" alt="image-20220320151552339"></p><p>（右上角切换Javaee透视图和debug透视图）</p><p><img src="https://nnu-zrh.oss-cn-hangzhou.aliyuncs.com/202307131541463.png" alt="image-20220320152202828"></p><p>（左边两个：直接到下一个断点；中止debug</p><p>右边四个：进入方法内部；进入下一语句；跳出方法内部；返回方法首行）</p></li></ul><h1 id="B-易错易混"><a href="#B-易错易混" class="headerlink" title="B. 易错易混"></a>B. 易错易混</h1><p>Test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个数组大小为n，数组的元素是存放double[]型数组的List</span></span><br><span class="line">List&lt;<span class="type">double</span>[]&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkList</span>[n]</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java语法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
